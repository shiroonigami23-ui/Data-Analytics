<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Advanced DFA / NFA / ε-NFA Studio — Complete v2</title>
<style>
/* ========= Theme & layout ========= */
:root{--bg1:#0b1220;--panel:#ffffff;--accent:#2563eb;--accent2:#7c3aed;--muted:#94a3b8}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#0b1220;background:linear-gradient(180deg,#071029,#071a2a);-webkit-font-smoothing:antialiased}
.app{max-width:1300px;margin:12px auto;padding:14px;display:flex;flex-direction:column;gap:12px}
.header{background:linear-gradient(90deg,var(--accent),var(--accent2));border-radius:12px;padding:14px;color:#fff;display:flex;align-items:center;gap:12px}
.header h1{margin:0;font-size:1.15rem}
.controls .row{display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap}
.controls button, .controls select, .controls input[type="text"], .controls textarea{padding:8px;border-radius:8px;border:1px solid #e6eef8;font-size:13px;background:#fff}
.small{font-size:12px;padding:6px}
.layout {
  display: grid;
  grid-template-columns: 360px 1fr;
  gap: 14px;
  flex: 1;               /* take remaining space under header */
  min-height: 0;         /* allow children to shrink properly */
}

.panel {
  background: var(--panel);
  padding: 12px;
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  min-height: 0;         /* prevents collapsing in flex/grid */
}

.panel.controls {
  overflow-y: auto;      /* independent scroll for controls */
}

.panel.svg-area {
  overflow-y: auto;      /* independent scroll for canvas */
}

.svg-area {
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-height: 0;
}
.svg-canvas {
  flex: 1;
  min-height: 300px;
  max-height: 80vh;
  background: #fff;
  border-radius: 8px;
  padding: 8px;
  border: 1px solid #e6eef8;
  display: block;         /* allow natural scrollbars */
  overflow: auto;         /* show scrollbars when needed */
  white-space: nowrap;    /* prevent auto-wrapping, enable horizontal scroll */
}

#dfaSVG {
  min-width: 100%;        /* allow natural growth */
  min-height: 100%;       /* allow natural growth */
  touch-action: none;
}

 /* Zoom Controls */
#zoomControls {
  width: 50px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  margin-left: 8px;
  padding: 8px;
  border-radius: 10px;
  background: #f9fafb;
  border: 1px solid #e6eef8;
}

#zoomControls button {
  width: 36px;
  height: 36px;
  border: none;
  border-radius: 50%;
  background: var(--accent);
  color: #fff;
  font-size: 16px;
  cursor: pointer;
  transition: background 0.2s;
}

#zoomControls button:hover {
  background: var(--accent2);
}

#zoomSlider {
  writing-mode: bt-lr; /* horizontal */
  -webkit-appearance: slider-horizontal;
  width: 8px;
  height: 120px;
  cursor: pointer;
  accent-color: var(--accent);
}

.sidebar-list{max-height:220px;overflow:auto;border:1px solid #e6eef8;border-radius:8px;padding:8px;background:#fbfdff}
.item{display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:6px}
.item:hover{background:#f3f7fb}
.tag{font-size:11px;padding:4px;border-radius:6px;background:#eef2ff;margin-left:6px}
.output{padding:10px;border-radius:8px;text-align:center;font-weight:700}
.output.info{background:linear-gradient(90deg,#ebf8ff,#dbeafe);color:#084298}
.output.success{background:linear-gradient(90deg,#ecfdf5,#bbf7d0);color:#065f46}
.output.error{background:linear-gradient(90deg,#ffe4e6,#fecaca);color:#881337}
kbd{background:#eef2ff;border-radius:6px;padding:4px 6px;font-size:12px;margin-left:6px}

/* svg graphics */
.state-circle{fill:#f8fafc;stroke:var(--accent);stroke-width:2.5;transition:all .18s;cursor:pointer}
.state-circle.final{stroke:#16a34a}
.state-circle.active{fill:#feffb3;stroke:#f59e0b;stroke-width:3}
.state-label{font-size:13px;font-weight:700;fill:#0b1220;text-anchor:middle;dominant-baseline:central;pointer-events:none}
.transition-path{fill:none;stroke:var(--accent);stroke-width:2;marker-end:url(#arrowhead);cursor:pointer}
.transition-path.active{stroke:#f59e0b;stroke-width:3}
.transition-label{font-size:12px;fill:#031124;font-weight:700;text-anchor:middle;pointer-events:none}

/* modal */
.modal{position:fixed;inset:0;background:rgba(2,6,23,0.65);display:none;align-items:center;justify-content:center;z-index:60}
.modal .box{background:#fff;padding:16px;border-radius:12px;max-width:980px;width:94%;max-height:80vh;overflow:auto}

/* responsive */
@media(max-width:980px){.layout{grid-template-columns:1fr}.panel{max-height:unset}}
button:focus, input:focus, select:focus{outline:3px solid rgba(37,99,235,0.16)}

/* collapsible headers */
.collapsible{cursor:pointer;display:flex;align-items:center;gap:8px;padding:6px 0;font-weight:700;color:#0b1220}
.collapsible .arrow{transition:transform .18s;font-size:14px;color:var(--accent);display:inline-block;transform-origin:center}
.collapsible.open .arrow{transform:rotate(90deg)}
.section-content{max-height:0;overflow:hidden;transition:max-height .25s ease-out,padding .18s; padding:0}
.section-content.open{padding:8px 0;max-height:999px;transition:max-height .28s ease-in,padding .18s}
/* ===== Modal Styling ===== */
.modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.modal-content {
  background: #fff;
  padding: 20px;
  border-radius: 10px;
  width: 280px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.2);
  text-align: center;
}

.modal-content h3 {
  margin-top: 0;
  font-size: 16px;
  color: var(--accent);
}

.modal-content input {
  width: 100%;
  padding: 8px;
  margin: 12px 0;
  border: 1px solid #e6eef8;
  border-radius: 6px;
}

.modal-actions {
  display: flex;
  justify-content: space-between;
  gap: 10px;
}

.modal-actions button {
  flex: 1;
  padding: 8px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: bold;
}

#renameCancel {
  background: #f1f5f9;
  color: #333;
}

#renameSave {
  background: var(--accent);
  color: #fff;
}
  .state-circle.highlighted {
  stroke: #f59e0b !important;  /* amber highlight */
  stroke-width: 4 !important;
}

#renameSave:hover {
  background: var(--accent2);
}
</style>
</head>
<body>
<div class="app" aria-live="polite">
  <div class="header" role="banner">
    <div style="flex:1">
      <h1>Advanced DFA / NFA / ε-NFA Studio — Complete v2</h1>
      <div style="font-size:13px;opacity:0.95">Full practise model. Works in Chrome (desktop & mobile).</div>
    </div>
    <div>
      <button id="downloadBtn" class="small">Download HTML</button>
    </div>
  </div>

  <div class="layout">
    
<aside class="panel controls" aria-label="Controls">
  <div style="display:flex;justify-content:space-between;align-items:center">
    <div><strong>Machine Controls</strong></div>
    <div style="font-size:12px;color:var(--muted)">Mode:
      <select id="modeSelect"><option value="DFA">DFA</option><option value="NFA">NFA</option><option value="ENFA">ε-NFA</option></select>
    </div>
  </div>
  <div class="row">
  <label for="modeToggle" style="font-size:12px;color:var(--muted)">Interaction:</label>
  <select id="modeToggle">
    <option value="move">Move States</option>
    <option value="rename">Rename States</option>
    <option value="transition">Create Transitions</option>
    <option value="delete">Delete</option>
  </select>
</div>


  <!-- States -->
  <div class="collapsible" data-target="section-states"><span class="arrow">▶</span> States</div>
  <div id="section-states" class="section-content">
    <div style="margin-top:8px" class="row">
      <input id="stateIdInput" type="text" placeholder="state id (q0)" />
      <button id="addStateBtn">Add State</button>
      <button id="autoLayoutBtn" class="small">Auto Layout</button>
    </div>

    <div class="row">
      <button id="setInitialBtn" class="small">Set Initial</button>
      <button id="toggleAcceptBtn" class="small">Toggle Accept</button>
      <button id="deleteStateBtn" class="small">Delete State</button>
    </div>
  </div>

  <!-- Transitions -->
  <div class="collapsible" data-target="section-transitions"><span class="arrow">▶</span> Transitions</div>
  <div id="section-transitions" class="section-content">
    <div style="margin-top:8px" class="row">
      <input id="fromInput" type="text" placeholder="from" />
      <input id="toInput" type="text" placeholder="to" />
    </div>
    <div class="row">
      <input id="symbolInput" type="text" placeholder="symbols (comma separated). 'ε' or 'eps' for epsilon" />
      <button id="addTransBtn">Add</button>
    </div>
  </div>

  <!-- Conversion & Minimization -->
  <div class="collapsible" data-target="section-conversion"><span class="arrow">▶</span> Conversion & Minimization</div>
  <div id="section-conversion" class="section-content">
    <div style="margin-top:8px" class="row">
      <button id="nfaToDfaBtn" class="small">NFA → DFA</button>
      <button id="enfaToDfaBtn" class="small">ε-NFA → DFA</button>
      <label><input type="checkbox" id="showIntermediate" checked/> Show intermediate</label>
    </div>
    <div class="row">
      <button id="minimizeBtn" class="small">Minimize DFA (Hopcroft)</button>
      <label><input type="checkbox" id="perStepExplanation" checked /> Explanations</label>
    </div>
  </div>

  <!-- ε-Closure Visualizer -->
  <div class="collapsible" data-target="section-closure"><span class="arrow">▶</span> ε-Closure Visualizer</div>
  <div id="section-closure" class="section-content">
    <div style="margin-top:8px" class="row">
      <select id="closureStateSelect"></select>
      <button id="closurePlay" class="small">Play</button>
      <button id="closurePause" class="small">Pause</button>
      <button id="closureStep" class="small">Step</button>
      <button id="closureBack" class="small">Back</button>
      <button id="closureReset" class="small">Reset</button>
      <button id="closureCopy" class="small">Copy</button>
    </div>
    <div id="closureLog" style="font-size:13px;margin-top:6px;color:#374151;min-height:36px"></div>
  </div>

  <!-- Animation & UX -->
  <div class="collapsible" data-target="section-animation"><span class="arrow">▶</span> Animation & UX</div>
  <div id="section-animation" class="section-content">
    <div style="margin-top:8px" class="row">
      <label>Speed <input type="range" id="animSpeed" min="50" max="1200" value="450" /></label>
      <label><input type="checkbox" id="visualVerbosity" checked /> Rich Animations</label>
      <label><input type="checkbox" id="limitAnim" /> Skip heavy animations</label>
    </div>
  </div>

  <!-- Save / Export -->
  <div class="collapsible" data-target="section-save"><span class="arrow">▶</span> Save / Export</div>
  <div id="section-save" class="section-content">
    <div style="margin-top:8px" class="row">
      <button id="saveLocalBtn">Save to localStorage</button>
      <button id="loadLocalBtn">Load from localStorage</button>
      <button id="clearLocalBtn">Clear Save</button>
    </div>
    <div class="row">
      <button id="exportJsonBtn">Export JSON</button>
      <button id="importJsonBtn">Import JSON</button>
    </div>
    <div class="row">
      <button id="exportPngBtn">Export PNG</button>
      <button id="exportSvgBtn">Export SVG</button>
      <button id="printSolutionBtn" class="small">Print Solution</button>
    </div>
  </div>

  <!-- Undo / Redo -->
  <div class="collapsible" data-target="section-undo"><span class="arrow">▶</span> Undo / Redo</div>
  <div id="section-undo" class="section-content">
    <div style="margin-top:8px" class="row">
      <button id="undoBtn" class="small">↶ Undo</button>
      <button id="redoBtn" class="small">↷ Redo</button>
      <label style="margin-left:auto">Autosave <input type="checkbox" id="autosaveToggle" checked /></label>
    </div>
  </div>

  <!-- States / Transitions lists -->
  <div class="collapsible" data-target="section-lists"><span class="arrow">▶</span> States & Transitions List</div>
  <div id="section-lists" class="section-content">
    <div style="margin-top:8px"><strong>States</strong></div>
    <div id="statesList" class="sidebar-list" aria-label="States list"></div>
    <div style="margin-top:8px"><strong>Transitions</strong></div>
    <div id="transList" class="sidebar-list" aria-label="Transitions list"></div>
  </div>

  <!-- Test Runner -->
  <div class="collapsible" data-target="section-test"><span class="arrow">▶</span> Test Runner</div>
  <div id="section-test" class="section-content">
    <div style="margin-top:8px" class="row">
      <input id="testInput" type="text" placeholder="test string" />
      <button id="runTestBtn">Run (DFA)</button>
      <button id="runNfaTestBtn" class="small">Run (NFA/ε-NFA)</button>
      <button id="stepBackBtn" class="small">Step Back</button>
    </div>
    <div id="runOutput" class="output info" role="status">Ready</div>
  </div>

  <!-- Practice Generator -->
  <div class="collapsible" data-target="section-practice"><span class="arrow">▶</span> Practice Generator</div>
  <div id="section-practice" class="section-content">
    <div style="margin-top:8px" class="row">
      <select id="practiceDifficulty"><option value="simple">Simple</option><option value="medium">Medium</option><option value="complex">Complex</option></select>
      <button id="genPracticeBtn">Generate</button>
      <button id="showSolutionBtn" class="small">Show Solution</button>
      <button id="resetPracticeBtn" class="small">Reset Problems</button>
    </div>
    <div id="practiceBox" style="margin-top:8px;font-size:13px;color:#374151;min-height:120px"></div>
  </div>

</aside>


    <main class="panel svg-area" aria-label="Visualization area">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Canvas</strong> — double-tap to delete a state</div>
        <div style="font-size:13px;color:var(--muted)">Shortcuts: <kbd>n</kbd> new, <kbd>Del</kbd> delete, <kbd>Ctrl+Z</kbd> undo</div>
      </div>
      <div style="display:flex; flex:1; position:relative;">
  <!-- Canvas -->
  <div class="svg-canvas" id="svgWrapper" tabindex="0" style="flex:1;">
    <svg id="dfaSVG" viewBox="0 0 1400 800" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Automaton canvas">
      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#2563eb"/>
        </marker>
        <marker id="arrowhead-active" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#f59e0b"/>
        </marker>
      </defs>
      <g id="edges"></g>
      <g id="states"></g>
      <g id="overlay"></g>
      <text id="canvasHint" x="700" y="400" text-anchor="middle" fill="#9aa6b2" font-size="18">Click/tap canvas to add a state</text>
    </svg>
  </div>

  <!-- Zoom Controls -->
  <div id="zoomControls" style="width:40px; display:flex; flex-direction:column; align-items:center; gap:8px; margin-left:6px;">
    <button id="zoomInBtn" title="Zoom In">+</button>
    <input type="range" id="zoomSlider" min="50" max="200" value="100" style="writing-mode: bt-lr; transform: rotate(270deg); width:120px;">
    <button id="zoomOutBtn" title="Zoom Out">−</button>
    <button id="zoomResetBtn" title="Reset Zoom">⟳</button>
  </div>
</div>

      <div style="display:flex;gap:8px;align-items:center;margin-top:10px">
        <button id="snapToggle" class="small">Snap-to-grid: Off</button>
        <button id="compactToggle" class="small">Compact Mode</button>
        <div style="margin-left:auto"><small style="color:#475569">Tip: Use 'Download HTML' to save a snapshot</small></div>
      </div>

      <div style="margin-top:12px"><strong>Step Log & Explanations</strong></div>
      <pre id="stepLog" style="padding:8px;background:#fff;border-radius:8px;height:260px;overflow:auto"></pre>
    </main>
  </div>

  <div style="font-size:12px;color:#cbd5e1;margin-top:8px">
    <strong>Changelog:</strong> Complete v2 — preserved original learning animations and UX, restored prior features, expanded practice bank (10+ per difficulty), added per-step natural-language explanations for conversions and minimization, full ε-closure visualizer (play/pause/step/back/copy), NFA branching runner visualization, animated subset construction with optional interleaved explanations, Hopcroft partition log, autosave with undo persistence, printable solution export, and performance safeguards.
  </div>
</div>

<!-- modal -->
<div id="modal" class="modal" role="dialog" aria-modal="true">
  <div class="box">
    <h3 id="modalTitle">Import / Paste JSON</h3>
    <textarea id="modalArea" rows="12" style="width:100%;padding:8px"></textarea>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
      <button id="modalCancel">Cancel</button>
      <button id="modalOk">OK</button>
    </div>
  </div>
</div>
<!-- Rename State Modal -->
<div id="renameModal" class="modal">
  <div class="modal-content">
    <h3>Rename State</h3>
    <input type="text" id="renameInput" placeholder="Enter new state name">
    <div class="modal-actions">
      <button id="renameCancel">Cancel</button>
      <button id="renameSave">Save</button>
    </div>
  </div>
</div>
<!-- Transition Modal -->
<div id="transitionModal" class="modal">
  <div class="modal-content">
    <h3>Add Transition</h3>
    <p id="transitionText"></p>
    <input type="text" id="transitionInput" placeholder="Enter symbol(s)">
    <div class="modal-actions">
      <button id="transitionCancel">Cancel</button>
      <button id="transitionSave">Save</button>
    </div>
  </div>
</div>

<script>

 /*  ============================= */

/* -----------------------------
   DOM & globals
   ----------------------------- */
const svg = document.getElementById('dfaSVG');
const edgesG = document.getElementById('edges');
const statesG = document.getElementById('states');
const overlay = document.getElementById('overlay');
const canvasHint = document.getElementById('canvasHint');
const stepLog = document.getElementById('stepLog');

const dom = {
  modeSelect: document.getElementById('modeSelect'),
  stateIdInput: document.getElementById('stateIdInput'),
  addStateBtn: document.getElementById('addStateBtn'),
  autoLayoutBtn: document.getElementById('autoLayoutBtn'),
  setInitialBtn: document.getElementById('setInitialBtn'),
  toggleAcceptBtn: document.getElementById('toggleAcceptBtn'),
  deleteStateBtn: document.getElementById('deleteStateBtn'),
  fromInput: document.getElementById('fromInput'),
  toInput: document.getElementById('toInput'),
  symbolInput: document.getElementById('symbolInput'),
  addTransBtn: document.getElementById('addTransBtn'),
  statesList: document.getElementById('statesList'),
  transList: document.getElementById('transList'),
  runTestBtn: document.getElementById('runTestBtn'),
  runNfaTestBtn: document.getElementById('runNfaTestBtn'),
  testInput: document.getElementById('testInput'),
  runOutput: document.getElementById('runOutput'),
  exportJsonBtn: document.getElementById('exportJsonBtn'),
  importJsonBtn: document.getElementById('importJsonBtn'),
  modal: document.getElementById('modal'),
  modalArea: document.getElementById('modalArea'),
  modalOk: document.getElementById('modalOk'),
  modalCancel: document.getElementById('modalCancel'),
  saveLocalBtn: document.getElementById('saveLocalBtn'),
  loadLocalBtn: document.getElementById('loadLocalBtn'),
  clearLocalBtn: document.getElementById('clearLocalBtn'),
  exportPngBtn: document.getElementById('exportPngBtn'),
  exportSvgBtn: document.getElementById('exportSvgBtn'),
  printSolutionBtn: document.getElementById('printSolutionBtn'),
  snapToggle: document.getElementById('snapToggle'),
  compactToggle: document.getElementById('compactToggle'),
  nfaToDfaBtn: document.getElementById('nfaToDfaBtn'),
  enfaToDfaBtn: document.getElementById('enfaToDfaBtn'),
  minimizeBtn: document.getElementById('minimizeBtn'),
  showIntermediate: document.getElementById('showIntermediate'),
  perStepExplanation: document.getElementById('perStepExplanation'),
  closureStateSelect: document.getElementById('closureStateSelect'),
  closurePlay: document.getElementById('closurePlay'),
  closurePause: document.getElementById('closurePause'),
  closureStep: document.getElementById('closureStep'),
  closureBack: document.getElementById('closureBack'),
  closureReset: document.getElementById('closureReset'),
  closureCopy: document.getElementById('closureCopy'),
  closureLog: document.getElementById('closureLog'),
  animSpeed: document.getElementById('animSpeed'),
  visualVerbosity: document.getElementById('visualVerbosity'),
  limitAnim: document.getElementById('limitAnim'),
  undoBtn: document.getElementById('undoBtn'),
  redoBtn: document.getElementById('redoBtn'),
  autosaveToggle: document.getElementById('autosaveToggle'),
  genPracticeBtn: document.getElementById('genPracticeBtn'),
  practiceDifficulty: document.getElementById('practiceDifficulty'),
  practiceBox: document.getElementById('practiceBox'),
  showSolutionBtn: document.getElementById('showSolutionBtn'),
  stepBackBtn: document.getElementById('stepBackBtn'),
  downloadBtn: document.getElementById('downloadBtn'),
};

/* -----------------------------
   Model & Undo/Redo (autosave)
   ----------------------------- */
let MACHINE = { name:'Advanced DFA', type:'DFA', states:[], transitions:[], alphabet:[] };
let UNDO_STACK = [];
let REDO_STACK = [];
let SNAP = false;
let dragging = null, pointerIdActive = null, lastTap = 0;
let closureTimer = null, closureSeq = [], closurePos = -1;
let animHistory = [], animPos = -1;
const STORAGE_KEY = 'ADFA_STUDIO_COMPLETE_V2';
const UNDO_KEY = 'ADFA_STUDIO_UNDO_V2';

function pushUndo(){ UNDO_STACK.push(JSON.stringify(MACHINE)); if (UNDO_STACK.length>500) UNDO_STACK.shift(); REDO_STACK=[]; updateUndoRedoButtons(); if (dom.autosaveToggle.checked) { localStorage.setItem(STORAGE_KEY, JSON.stringify(MACHINE)); localStorage.setItem(UNDO_KEY, JSON.stringify(UNDO_STACK)); } }
function doUndo(){ if (!UNDO_STACK.length) return; REDO_STACK.push(JSON.stringify(MACHINE)); MACHINE = JSON.parse(UNDO_STACK.pop()); renderAll(); updateUndoRedoButtons(); if (dom.autosaveToggle.checked) localStorage.setItem(STORAGE_KEY, JSON.stringify(MACHINE)); }
function doRedo(){ if (!REDO_STACK.length) return; UNDO_STACK.push(JSON.stringify(MACHINE)); MACHINE = JSON.parse(REDO_STACK.pop()); renderAll(); updateUndoRedoButtons(); if (dom.autosaveToggle.checked) localStorage.setItem(STORAGE_KEY, JSON.stringify(MACHINE)); }
function updateUndoRedoButtons(){ dom.undoBtn.disabled = UNDO_STACK.length===0; dom.redoBtn.disabled = REDO_STACK.length===0; }

function showMessage(text,type='info'){ dom.runOutput.textContent = text; dom.runOutput.className = 'output ' + (type==='info'?'info': type==='success'?'success':'error'); }
function delay(ms){ return new Promise(r=>setTimeout(r,ms)); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* -----------------------------
   Model operations
   ----------------------------- */
function updateAlphabetFromTransitions(){ const set = new Set(); MACHINE.transitions.forEach(t=>{ if (t.symbol!=='ε') set.add(t.symbol); }); MACHINE.alphabet = Array.from(set).sort(); }

function addStateAt(id,x=200+Math.random()*900,y=160+Math.random()*520){
  if (!id) id = `q${MACHINE.states.length}`;
  if (MACHINE.states.some(s=>s.id===id)){ showMessage('State id exists','error'); return null; }
  pushUndo();
  MACHINE.states.push({ id, x, y, initial: MACHINE.states.length===0, accepting:false });
  updateAlphabetFromTransitions(); renderAll(); return id;
}
function deleteState(id){ const idx=MACHINE.states.findIndex(s=>s.id===id); if (idx<0) return; pushUndo(); MACHINE.states.splice(idx,1); MACHINE.transitions = MACHINE.transitions.filter(t=>t.from!==id && t.to!==id); updateAlphabetFromTransitions(); renderAll(); }
function setInitial(id){ pushUndo(); MACHINE.states.forEach(s=>s.initial=false); const s=MACHINE.states.find(st=>st.id===id); if (s) s.initial=true; renderAll(); }
function toggleAccept(id){ pushUndo(); const s=MACHINE.states.find(st=>st.id===id); if (s) s.accepting=!s.accepting; renderAll(); }
function renameState(oldId,newId){ if (MACHINE.states.some(s=>s.id===newId)){ showMessage('New id exists','error'); return; } pushUndo(); MACHINE.states.forEach(s=>{ if (s.id===oldId) s.id=newId; }); MACHINE.transitions.forEach(t=>{ if (t.from===oldId) t.from=newId; if (t.to===oldId) t.to=newId; }); renderAll(); }

/* Strict enforcement for DFA mode */
function enforceModeStrict(){
  if (MACHINE.type === 'DFA'){
    const eps = MACHINE.transitions.filter(t=>t.symbol==='ε');
    if (eps.length){
      if (!confirm(`DFA mode: remove ${eps.length} ε-transition(s)?`)) return false;
      pushUndo();
      MACHINE.transitions = MACHINE.transitions.filter(t=>t.symbol!=='ε');
    }
    // remove duplicates for (from,symbol)
    const seen = new Set(); const kept = [];
    for (const t of MACHINE.transitions){
      const key = `${t.from}|${t.symbol}`;
      if (!seen.has(key)){ seen.add(key); kept.push(t); }
    }
    if (kept.length !== MACHINE.transitions.length){
      if (!confirm('DFA mode: remove ambiguous transitions (keep first)?')) return false;
      pushUndo();
      MACHINE.transitions = kept;
    }
    updateAlphabetFromTransitions(); renderAll();
  }
  return true;
}

function addTransition(from,to,symbol){
  if (!from||!to||!symbol){ showMessage('Fill from/to/symbol','error'); return; }
  if (!MACHINE.states.find(s=>s.id===from) || !MACHINE.states.find(s=>s.id===to)){ showMessage('Unknown state id(s)','error'); return; }
  const symbols = symbol.split(',').map(s=>s.trim()).filter(s=>s.length);
  const fixed = symbols.map(s=> s==='eps'||s==='e' ? 'ε' : s);
  if (MACHINE.type==='DFA'){
    if (fixed.some(s=>s==='ε')){ showMessage('ε not allowed in DFA mode','error'); return; }
    for (const sym of fixed) if (MACHINE.transitions.find(t=>t.from===from && t.symbol===sym)){ showMessage(`Transition from ${from} on ${sym} exists (DFA)`,'error'); return; }
  }
  pushUndo();
  fixed.forEach(sym=>MACHINE.transitions.push({ from,to,symbol:sym }));
  updateAlphabetFromTransitions(); renderAll();
}
function deleteTransition(idx){ if (idx<0||idx>=MACHINE.transitions.length) return; pushUndo(); MACHINE.transitions.splice(idx,1); updateAlphabetFromTransitions(); renderAll(); }

/* -----------------------------
   Rendering (SVG + sidebar)
   ----------------------------- */
function clearSvg(){ edgesG.innerHTML=''; statesG.innerHTML=''; overlay.innerHTML=''; }
function renderAll(){ clearSvg(); renderTransitions(); renderStates(); renderSidebar(); updateClosureSelect(); canvasHint.style.display = MACHINE.states.length ? 'none' : 'block'; if (dom.autosaveToggle.checked) localStorage.setItem(STORAGE_KEY, JSON.stringify(MACHINE)); }
function renderStates() {
  statesG.innerHTML = "";
  MACHINE.states.forEach((s) => {
    const g = createSVG("g", { "data-id": s.id });

    const circle = createSVG("circle", {
      cx: s.x,
      cy: s.y,
      r: 28,
      class: "state-circle",
      "data-id": s.id
    });

    const label = createSVG("text", {
      x: s.x,
      y: s.y + 4,
      class: "state-label"
    });
    label.textContent = s.label || s.id;

    // === Unified event handler depending on mode ===
    circle.addEventListener("pointerdown", (ev) => {
      const mode = document.getElementById("modeToggle").value;

      if (mode === "move" ||mode === "rename") {
        // ✅ start dragging state
        startMoveState(ev, s.id);
      } 
      else if (mode === "transition") {
        // ✅ start creating transition
        handleTransitionClick(s.id);
      } 
      else if (mode === "delete") {
        // ✅ delete state + its transitions
        if (confirm(`Delete state ${s.id} and all its transitions?`)) {
          deleteState(s.id);
        }
      }
      // 🚫 no rename here → handled in pointerup if mode = rename and no drag
    });

    g.appendChild(circle);
    g.appendChild(label);
    statesG.appendChild(g);
  });
}


function createSVG(name,attrs={}){ const el=document.createElementNS('http://www.w3.org/2000/svg',name); for(const k in attrs) el.setAttribute(k,attrs[k]); return el; }
function renderSidebar(){ dom.statesList.innerHTML=''; dom.transList.innerHTML=''; MACHINE.states.forEach(s=>{ const div=document.createElement('div'); div.className='item'; const left=document.createElement('div'); left.innerHTML=`<strong>${s.id}</strong> ${s.initial?'<span class="tag">init</span>':''} ${s.accepting?'<span class="tag">accept</span>':''}`; const right=document.createElement('div'); const setI=document.createElement('button'); setI.textContent='I'; setI.onclick=()=>setInitial(s.id); const acc=document.createElement('button'); acc.textContent='F'; acc.onclick=()=>toggleAccept(s.id); const ren=document.createElement('button'); ren.textContent='✎'; ren.onclick=()=>{ const nid=prompt('Rename state',s.id); if (nid&&nid!==s.id) renameState(s.id,nid); }; const del=document.createElement('button'); del.textContent='✕'; del.onclick=()=>{ if (confirm('Delete state?')) deleteState(s.id); }; right.appendChild(setI); right.appendChild(acc); right.appendChild(ren); right.appendChild(del); div.appendChild(left); div.appendChild(right); dom.statesList.appendChild(div); }); MACHINE.transitions.forEach((t,i)=>{ const div=document.createElement('div'); div.className='item'; div.innerHTML=`<div><strong>${t.from} → ${t.to}</strong> <span class="tag">${t.symbol}</span></div>`; const right=document.createElement('div'); const del=document.createElement('button'); del.textContent='Delete'; del.onclick=()=>{ if (confirm('Delete transition?')) deleteTransition(i); }; right.appendChild(del); div.appendChild(right); dom.transList.appendChild(div); }); updateUndoRedoButtons(); }

/* -----------------------------
   Pointer dragging for states (touch friendly)
   ----------------------------- */
function statePointerDown(ev){
  ev.preventDefault(); ev.stopPropagation();
  const g = ev.target.closest('g'); if (!g) return;
  const id = g.getAttribute('data-id');
  pointerIdActive = ev.pointerId;
  dragging = { id, startX: ev.clientX, startY: ev.clientY, origX:null, origY:null };
  const s = MACHINE.states.find(x=>x.id===id);
  if (s){ dragging.origX=s.x; dragging.origY=s.y; }
  svg.setPointerCapture(ev.pointerId);
  svg.addEventListener('pointermove', statePointerMove);
  svg.addEventListener('pointerup', statePointerUp);
  svg.addEventListener('pointercancel', statePointerUp);
}
  function renderTransitions() {
  MACHINE.transitions.forEach((t, i) => {
    const A = MACHINE.states.find(s => s.id === t.from);
    const B = MACHINE.states.find(s => s.id === t.to);
    if (!A || !B) return;

    if (A.id === B.id) {
      // self-loop
      const path = createSVG('path', {
        d: `M${A.x} ${A.y - 28} C ${A.x + 40} ${A.y - 80} ${A.x - 40} ${A.y - 80} ${A.x} ${A.y - 28}`,
        class: 'transition-path',
        'data-idx': i,
        'marker-end': 'url(#arrowhead)'
      });
      edgesG.appendChild(path);

      const label = createSVG('text', {
        x: A.x,
        y: A.y - 82,
        class: 'transition-label'
      });
      label.textContent = t.symbol;
      edgesG.appendChild(label);

      // delete mode listener
      path.addEventListener('pointerdown', (ev) => {
        const mode = document.getElementById('modeToggle').value;
        if (mode === 'delete') {
          if (confirm('Delete this transition?')) {
            deleteTransition(i);
          }
        }
      });

      return;
    }

    // normal A → B transition
    const mx = (A.x + B.x) / 2, my = (A.y + B.y) / 2;
    const dx = B.x - A.x, dy = B.y - A.y;
    const dr = Math.sqrt(dx * dx + dy * dy);
    const nx = dx / dr, ny = dy / dr;

    const startX = A.x + nx * 30, startY = A.y + ny * 30;
    const endX = B.x - nx * 30, endY = B.y - ny * 30;
    const cx = (startX + endX) / 2 - ny * 36, cy = (startY + endY) / 2 + nx * 36;
    const d = `M${startX} ${startY} Q ${cx} ${cy} ${endX} ${endY}`;

    const path = createSVG('path', {
      d,
      class: 'transition-path',
      'data-idx': i,
      'marker-end': 'url(#arrowhead)'
    });
    edgesG.appendChild(path);

    const label = createSVG('text', {
      x: mx - ny * 20,
      y: my + nx * 20,
      class: 'transition-label'
    });
    label.textContent = t.symbol;
    edgesG.appendChild(label);

    // delete mode listener
    path.addEventListener('pointerdown', (ev) => {
      const mode = document.getElementById('modeToggle').value;
      if (mode === 'delete') {
        if (confirm('Delete this transition?')) {
          deleteTransition(i);
        }
      }
    });
  });
}

function statePointerMove(ev){
  if (!dragging || ev.pointerId!==pointerIdActive) return;
  ev.preventDefault();
  const s = MACHINE.states.find(x=>x.id===dragging.id); if (!s) return;
  const rect = svg.getBoundingClientRect();
  const vx = ((ev.clientX - rect.left)/rect.width)*1400;
  const vy = ((ev.clientY - rect.top)/rect.height)*800;
  s.x = SNAP ? Math.round(vx/20)*20 : clamp(vx,40,1360);
  s.y = SNAP ? Math.round(vy/20)*20 : clamp(vy,40,760);
  renderAll();
}
function statePointerUp(ev) {
  if (!dragging || ev.pointerId !== pointerIdActive) return;

  svg.removeEventListener("pointermove", statePointerMove);
  svg.removeEventListener("pointerup", statePointerUp);
  svg.removeEventListener("pointercancel", statePointerUp);

  const mode = document.getElementById("modeToggle").value;

  if (mode === "move") {
    // ✅ only finish dragging
    pushUndo();
  }
  else if (
    mode === "rename" &&
    Math.abs(ev.clientX - dragging.startX) < 5 &&
    Math.abs(ev.clientY - dragging.startY) < 5
  ) {
    // ✅ only trigger rename if it was a click (not a drag)
    const s = MACHINE.states.find(st => st.id === dragging.id);
    if (s) openRenameModal(s);
  }

  dragging = null;
  pointerIdActive = null;
}
function statePointerUp(ev) {
  if (!dragging || ev.pointerId !== pointerIdActive) return;

  svg.removeEventListener("pointermove", statePointerMove);
  svg.removeEventListener("pointerup", statePointerUp);
  svg.removeEventListener("pointercancel", statePointerUp);

  const mode = document.getElementById("modeToggle").value;

  if (mode === "move") {
    // ✅ only finish dragging
    pushUndo();
  }
  else if (
    mode === "rename" &&
    Math.abs(ev.clientX - dragging.startX) < 5 &&
    Math.abs(ev.clientY - dragging.startY) < 5
  ) {
    // ✅ only trigger rename if it was a click (not a drag)
    const s = MACHINE.states.find(st => st.id === dragging.id);
    if (s) openRenameModal(s);
  }

  dragging = null;
  pointerIdActive = null;
}

function onStatePointerUp(ev){}

/* -----------------------------
   Keyboard shortcuts
   ----------------------------- */
window.addEventListener('keydown',(e)=>{
  if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); doUndo(); }
  if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='y'){ e.preventDefault(); doRedo(); }
  if (e.key.toLowerCase()==='n'){ dom.stateIdInput.focus(); }
  if (e.key==='Delete'){ const id=prompt('Delete which state?'); if (id) deleteState(id); }
});

/* -----------------------------
   DFA test runner (animated)
   ----------------------------- */
function* runDfaGenerator(dfa,input){
  const initial = dfa.states.find(s=>s.initial);
  if (!initial){ yield {error:'No initial state'}; return; }
  let cur = initial.id; yield {step:`Start at ${cur}`, state:cur};
  for (let i=0;i<input.length;i++){
    const sym = input[i];
    const t = dfa.transitions.find(tr=>tr.from===cur && tr.symbol===sym);
    if (!t){ yield {error:`No transition from ${cur} on '${sym}'`}; return; }
    cur = t.to; yield {step:`Read '${sym}' → ${cur}`, state:cur};
  }
  const accept = Boolean(dfa.states.find(s=>s.id===cur && s.accepting));
  yield {result:accept, step:`Final: ${cur} (${accept?'ACCEPT':'REJECT'})`, state:cur};
}
let activeIterator = null;
function animateGenerator(genFunc){
  animHistory = []; animPos = -1;
  const it = genFunc();
  activeIterator = it;
  async function step(){
    const r = it.next();
    if (r.done) return;
    const v = r.value;
    if (v.error){ showMessage(v.error,'error'); return; }
    animHistory.push(v); animPos = animHistory.length-1; renderAnimState(v);
    if (v.result!==undefined){ showMessage(v.step, v.result?'success':'error'); return; }
    await delay(dom.animSpeed.value||450); step();
  }
  step();
}
function renderAnimState(v){ clearHighlights(); if (v.state) highlightState(v.state); showMessage(v.step,'info'); }
dom.stepBackBtn.addEventListener('click', ()=>{ if (animPos<=0){ showMessage('No previous step','error'); return; } animPos--; const v = animHistory[animPos]; renderAnimState(v); });

/* -----------------------------
   NFA/ε-NFA runner (branching visualization)
   ----------------------------- */
async function runNfaAnimated(transitions,states,input,withEpsilon=true){
  const initial = states.find(s=>s.initial);
  if (!initial){ showMessage('No initial state','error'); return; }
  let active = new Set([initial.id]);
  if (withEpsilon) active = new Set(eClosureOf(Array.from(active), transitions));
  highlightSet(Array.from(active)); showMessage(`Start: {${Array.from(active).join(',')}}`,'info');
  await delay(dom.animSpeed.value||450);
  for (let i=0;i<input.length;i++){
    const sym = input[i];
    const next = new Set();
    for (const q of Array.from(active)){
      transitions.filter(t=>t.from===q && t.symbol===sym).forEach(t=>next.add(t.to));
    }
    if (withEpsilon){
      const after = new Set(eClosureOf(Array.from(next), transitions));
      next.clear();
      for (const q of after) next.add(q);
    }
    showMessage(`On '${sym}' → {${Array.from(next).join(',')}}`,'info');
    highlightSet(Array.from(next)); highlightTransitionsFromSet(Array.from(active), sym);
    await delay(dom.animSpeed.value||450);
    active = next;
  }
  const accept = Array.from(active).some(a=>states.find(s=>s.id===a && s.accepting));
  showMessage(`Final: {${Array.from(active).join(',')}} → ${accept?'ACCEPT':'REJECT'}`, accept?'success':'error');
  highlightSet(Array.from(active));
}
dom.runNfaTestBtn.addEventListener('click', ()=>{ const input = dom.testInput.value.trim(); runNfaAnimated(MACHINE.transitions, MACHINE.states, input, MACHINE.type==='ENFA'); });

/* -----------------------------
   ε-closure visualizer (play/pause/step/back/copy)
   ----------------------------- */
function eClosureOf(set, transitions){
  const closure = new Set(set);
  const stack = [...set];
  while (stack.length){
    const s = stack.pop();
    for (const t of transitions.filter(tr=>tr.from===s && tr.symbol==='ε')){
      if (!closure.has(t.to)){ closure.add(t.to); stack.push(t.to); }
    }
  }
  return Array.from(closure);
}
function nfaMove(set, symbol, transitions){
  const res = new Set();
  for (const q of set) for (const t of transitions.filter(tr=>tr.from===q && tr.symbol===symbol)) res.add(t.to);
  return Array.from(res);
}
dom.closurePlay.addEventListener('click', ()=>{
  const start = dom.closureStateSelect.value; if (!start){ showMessage('Pick a state','error'); return; }
  closureSeq = [[start]]; closurePos = 0; dom.closureLog.textContent = `Step 0: {${start}}`; highlightSet([start]);
  if (closureTimer) clearInterval(closureTimer);
  closureTimer = setInterval(()=>{
    const cur = closureSeq[closurePos];
    const expanded = new Set(cur);
    for (const q of cur) MACHINE.transitions.filter(t=>t.from===q && t.symbol==='ε').forEach(t=>expanded.add(t.to));
    const arr = Array.from(expanded).sort();
    closurePos++;
    if (arr.length===cur.length || arr.length>500){ dom.closureLog.textContent += `\nFinal: {${arr.join(',')}}`; highlightSet(arr); clearInterval(closureTimer); closureTimer=null; return; }
    closureSeq.push(arr); dom.closureLog.textContent += `\nStep ${closurePos}: {${arr.join(',')}}`; highlightSet(arr);
  }, dom.animSpeed.value||450);
});
dom.closurePause.addEventListener('click', ()=>{ if (closureTimer){ clearInterval(closureTimer); closureTimer=null; showMessage('Paused','info'); } else showMessage('Nothing to pause','error'); });
dom.closureStep.addEventListener('click', ()=>{ const start = dom.closureStateSelect.value; if (!start){ showMessage('Pick a state','error'); return; } if (closureSeq.length===0){ closureSeq=[[start]]; closurePos=0; dom.closureLog.textContent=`Step 0: {${start}}`; highlightSet([start]); return; } const cur = closureSeq[closureSeq.length-1]; const expanded=new Set(cur); for (const q of cur) MACHINE.transitions.filter(t=>t.from===q && t.symbol==='ε').forEach(t=>expanded.add(t.to)); const arr=Array.from(expanded).sort(); closureSeq.push(arr); closurePos=closureSeq.length-1; dom.closureLog.textContent += `\nStep ${closurePos}: {${arr.join(',')}}`; highlightSet(arr); });
dom.closureBack.addEventListener('click', ()=>{ if (closureSeq.length<=1){ showMessage('No previous step','error'); return; } closureSeq.pop(); closurePos=closureSeq.length-1; dom.closureLog.textContent += `\nBack to Step ${closurePos}: {${closureSeq[closurePos].join(',')}}`; highlightSet(closureSeq[closurePos]); });
dom.closureReset.addEventListener('click', ()=>{ closureSeq=[]; closurePos=-1; dom.closureLog.textContent=''; clearHighlights(); if (closureTimer){ clearInterval(closureTimer); closureTimer=null; } });
dom.closureCopy.addEventListener('click', ()=>{ const arr = closureSeq[closureSeq.length-1]||[]; navigator.clipboard && navigator.clipboard.writeText(JSON.stringify(arr)).then(()=>showMessage('Copied closure','success')); });

function highlightSet(setIds){ clearHighlights(); for (const id of setIds){ const el = statesG.querySelector(`g[data-id="${id}"] circle`); if (el) el.classList.add('active'); } }
function highlightState(id){ clearHighlights(); const el = statesG.querySelector(`g[data-id="${id}"] circle`); if (el) el.classList.add('active'); }
function clearHighlights(){ statesG.querySelectorAll('circle.active').forEach(c=>c.classList.remove('active')); edgesG.querySelectorAll('.transition-path.active').forEach(e=>e.classList.remove('active')); }
function highlightTransitionsFromSet(fromSet, symbol){ edgesG.querySelectorAll('.transition-path').forEach(p=>p.classList.remove('active')); MACHINE.transitions.forEach((t,i)=>{ if (fromSet.includes(t.from) && t.symbol===symbol){ const el = edgesG.querySelector(`path[data-idx="${i}"]`); if (el) el.classList.add('active'); } }); }

/* -----------------------------
   Subset construction (animated) — NFA/ε-NFA → DFA
   ----------------------------- */
async function enfaToDfaAnimated(){
  if (MACHINE.type !== 'ENFA'){ showMessage('Switch to ε-NFA mode','error'); return; }
  if (dom.limitAnim.checked && MACHINE.states.length>60){ if (!confirm('Large machine — skip animations?')) return; }
  pushUndo();
  stepLog.textContent = ''; const start = MACHINE.states.find(s=>s.initial); if (!start){ showMessage('No initial state','error'); return; }
  const q0 = eClosureOf([start.id], MACHINE.transitions).sort();
  const dStates=[q0]; const mapKey=s=>s.join(','); const map={}; map[mapKey(q0)]='D0';
  const newStates=[{id:'D0',members:q0,initial:true,accepting:q0.some(m=>MACHINE.states.find(st=>st.id===m && st.accepting))}]; const newTrans=[];
  let idx=0;
  while (idx<dStates.length){
    const S=dStates[idx]; const name=mapKey(S); logStep(`Processing set: {${S.join(',')}}`); await animateDelayShort();
    const alph = MACHINE.alphabet.slice();
    for (const a of alph){
      const moved = nfaMove(S,a,MACHINE.transitions); const closure = eClosureOf(moved, MACHINE.transitions).sort();
      if (closure.length===0) continue;
      if (!map[mapKey(closure)]){ const newid='D'+Object.keys(map).length; map[mapKey(closure)] = newid; dStates.push(closure); newStates.push({id:newid,members:closure,initial:false,accepting:closure.some(m=>MACHINE.states.find(st=>st.id===m && st.accepting))}); logStep(`Create DFA state ${newid} = {${closure.join(',')}}`); if (dom.showIntermediate.checked) await animateDelayShort(); }
      const from = map[name], to = map[mapKey(closure)];
      newTrans.push({from,to,symbol:a}); logStep(`Add transition ${from} -${a}-> ${to}`); if (dom.showIntermediate.checked) await animateDelay(120);
    }
    idx++;
  }
  MACHINE = { name: MACHINE.name + ' (from ε-NFA)', type:'DFA', states: newStates.map(s=>({ id:s.id, x:100+Math.random()*1100, y:80+Math.random()*640, initial:!!s.initial, accepting:!!s.accepting })), transitions: newTrans, alphabet: MACHINE.alphabet.slice() };
  renderAll(); showMessage('ε-NFA → DFA done','success');
}

async function nfaToDfaAnimated(){
  if (MACHINE.type !== 'NFA'){ showMessage('Switch to NFA mode','error'); return; }
  if (dom.limitAnim.checked && MACHINE.states.length>60){ if (!confirm('Large machine — skip animations?')) return; }
  pushUndo(); stepLog.textContent = ''; const start = MACHINE.states.find(s=>s.initial); if (!start){ showMessage('No initial state','error'); return; }
  const q0=[start.id].sort(); const dStates=[q0]; const mapKey=s=>s.join(','); const map={}; map[mapKey(q0)]='D0';
  const newStates=[{id:'D0',members:q0,initial:true,accepting:q0.some(m=>MACHINE.states.find(st=>st.id===m && st.accepting))}]; const newTrans=[];
  let idx=0;
  while (idx<dStates.length){
    const S=dStates[idx]; const name=mapKey(S); logStep(`Processing set: {${S.join(',')}}`); await animateDelayShort();
    for (const a of MACHINE.alphabet){
      const moved = nfaMove(S,a,MACHINE.transitions).sort(); if (moved.length===0) continue;
      if (!map[mapKey(moved)]){ const newid='D'+Object.keys(map).length; map[mapKey(moved)]=newid; dStates.push(moved); newStates.push({id:newid,members:moved,initial:false,accepting:moved.some(m=>MACHINE.states.find(st=>st.id===m && st.accepting))}); logStep(`Create DFA state ${newid} = {${moved.join(',')}}`); if (dom.showIntermediate.checked) await animateDelayShort(); }
      const from = map[name], to = map[mapKey(moved)]; newTrans.push({from,to,symbol:a}); logStep(`Add transition ${from} -${a}-> ${to}`); if (dom.showIntermediate.checked) await animateDelay(120);
    }
    idx++;
  }
  MACHINE = { name: MACHINE.name + ' (from NFA)', type:'DFA', states:newStates.map(s=>({ id:s.id, x:100+Math.random()*1100, y:80+Math.random()*640, initial:!!s.initial, accepting:!!s.accepting })), transitions:newTrans, alphabet:MACHINE.alphabet.slice() };
  renderAll(); showMessage('NFA → DFA done','success');
}

/* -----------------------------
   Hopcroft minimization with explanations
   ----------------------------- */
function minimizeDFA_Hopcroft(){
  if (MACHINE.type !== 'DFA'){ showMessage('Switch to DFA mode','error'); return; }
  pushUndo();
  const states = MACHINE.states.map(s=>s.id); const alphabet = MACHINE.alphabet.slice();
  const accepting = new Set(MACHINE.states.filter(s=>s.accepting).map(s=>s.id)); const nonAccepting = states.filter(s=>!accepting.has(s));
  let P = [ accepting.size?Array.from(accepting):[], nonAccepting.length?nonAccepting:[] ].filter(x=>x.length);
  let W = P.slice(); stepLog.textContent = 'Hopcroft minimization steps:\n'; const explanations=[];
  while (W.length){
    const A = W.pop(); stepLog.textContent += `Processing partition: {${A.join(',')}}\n`; if (dom.perStepExplanation.checked) explanations.push(`We consider partition {${A.join(',')}} as splitter.`);
    for (const c of alphabet){
      const X = new Set(); for (const t of MACHINE.transitions) if (t.symbol===c && A.includes(t.to)) X.add(t.from);
      stepLog.textContent += `  Symbol '${c}': X = {${Array.from(X).join(',')}}\n`; if (dom.perStepExplanation.checked) explanations.push(`For symbol '${c}', states moving into splitter are {${Array.from(X).join(',')}}.`);
      const newP = [];
      for (const Y of P){
        const inter = Y.filter(x=>X.has(x)); const diff = Y.filter(x=>!X.has(x));
        if (inter.length && diff.length){
          newP.push(inter); newP.push(diff);
          const idx = W.findIndex(x=>x===Y);
          if (idx>=0){ W.splice(idx,1); W.push(inter); W.push(diff); } else { if (inter.length <= diff.length) W.push(inter); else W.push(diff); }
          stepLog.textContent += `    Split {${Y.join(',')}} into {${inter.join(',')}} and {${diff.join(',')}}\n`;
          if (dom.perStepExplanation.checked) explanations.push(`Partition {${Y.join(',')}} split because some states on '${c}' go into the splitter.`);
        } else newP.push(Y);
      }
      P = newP;
    }
  }
  const map = {}; P.forEach((block,i)=>block.forEach(s=>map[s]='M'+i));
  const newStates = P.map((block,i)=> ({ id:'M'+i, x:100+Math.random()*1100, y:80+Math.random()*640, initial:block.some(s=>MACHINE.states.find(st=>st.id===s && st.initial)), accepting:block.some(s=>MACHINE.states.find(st=>st.id===s && st.accepting)) }) );
  const newTrans = [];
  for (const t of MACHINE.transitions){
    const from = map[t.from], to = map[t.to];
    if (!newTrans.find(x=>x.from===from && x.symbol===t.symbol)) newTrans.push({ from,to,symbol:t.symbol });
  }
  stepLog.textContent += '\nFinal partitions: ' + P.map(p=>'{' + p.join(',') + '}').join(', ') + '\n';
  if (dom.perStepExplanation.checked) stepLog.textContent += '\nExplanations:\n' + explanations.join('\n');
  MACHINE = { name: MACHINE.name + ' (minimized)', type:'DFA', states:newStates, transitions:newTrans, alphabet:alphabet };
  renderAll(); showMessage('Minimization complete','success');
}
document.querySelectorAll('.collapsible').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.getAttribute('data-target');
    const content = document.getElementById(target);
    if (!content) return;
    btn.classList.toggle('open');
    content.classList.toggle('open');
  });
});
// Ensure all sections are collapsed by default (they are), but we attach showing for accessibility
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape'){
    document.querySelectorAll('.section-content.open').forEach(c=>{ c.classList.remove('open'); const btn = document.querySelector(`.collapsible[data-target="${c.id}"]`); if(btn) btn.classList.remove('open'); });
  }
});
/* -----------------------------
   Auto-layout (circular/grid)
   ----------------------------- */
function autoLayout(){
  const n = MACHINE.states.length; if (n===0) return; pushUndo();
  if (n<=80){
    const cx=700, cy=400, r=Math.min(360, 60 + n*4);
    for (let i=0;i<n;i++){ const a=(i/n)*Math.PI*2; MACHINE.states[i].x = cx + Math.cos(a)*r; MACHINE.states[i].y = cy + Math.sin(a)*r; }
  } else {
    const cols = Math.ceil(Math.sqrt(n)); const spacingX = 120, spacingY=110;
    for (let i=0;i<n;i++){ const row=Math.floor(i/cols), col=i%cols; MACHINE.states[i].x=80+col*spacingX; MACHINE.states[i].y=80+row*spacingY; }
  }
  renderAll();
}

/* -----------------------------
   Utilities & export
   ----------------------------- */
function logStep(text){ stepLog.textContent += text + "\n"; stepLog.scrollTop = stepLog.scrollHeight; }
function animateDelay(ms){ return delay(ms || dom.animSpeed.value); }
function animateDelayShort(){ return delay(Math.max(80, Math.min(600, (dom.animSpeed.value||450)/1.6))); }

dom.exportJsonBtn.addEventListener('click', ()=>{ const blob = new Blob([JSON.stringify(MACHINE,null,2)],{type:'application/json'}); const u = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=u; a.download=(MACHINE.name||'machine')+'.json'; a.click(); URL.revokeObjectURL(u); });
dom.importJsonBtn.addEventListener('click', ()=>{ dom.modal.style.display='flex'; document.getElementById('modalTitle').textContent='Import JSON'; dom.modalArea.value=''; });
dom.modalCancel.addEventListener('click', ()=>dom.modal.style.display='none');
dom.modalOk.addEventListener('click', ()=>{ try{ const obj = JSON.parse(dom.modalArea.value); MACHINE = obj; pushUndo(); renderAll(); dom.modal.style.display='none'; showMessage('Imported','success'); }catch(e){ alert('Invalid JSON'); } });

dom.saveLocalBtn.addEventListener('click', ()=>{ localStorage.setItem(STORAGE_KEY, JSON.stringify(MACHINE)); localStorage.setItem(UNDO_KEY, JSON.stringify(UNDO_STACK)); showMessage('Saved to localStorage','success'); });
dom.loadLocalBtn.addEventListener('click', ()=>{ const s=localStorage.getItem(STORAGE_KEY); if (!s){ showMessage('No saved machine','error'); return; } MACHINE=JSON.parse(s); const us=localStorage.getItem(UNDO_KEY); if (us) UNDO_STACK=JSON.parse(us); renderAll(); showMessage('Loaded from localStorage','success'); });
dom.clearLocalBtn.addEventListener('click', ()=>{ localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(UNDO_KEY); showMessage('Cleared saved data','success'); });

dom.exportSvgBtn.addEventListener('click', ()=>{ const serializer = new XMLSerializer(); const svgStr = serializer.serializeToString(svg); const blob = new Blob([svgStr],{type:'image/svg+xml'}); const u = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=u; a.download=(MACHINE.name||'machine')+'.svg'; a.click(); URL.revokeObjectURL(u); });
dom.exportPngBtn.addEventListener('click', ()=>{ const serializer = new XMLSerializer(); const svgStr = serializer.serializeToString(svg); const img=new Image(); const svgBlob = new Blob([svgStr],{type:'image/svg+xml;charset=utf-8'}); const url = URL.createObjectURL(svgBlob); img.onload=function(){ const canvas=document.createElement('canvas'); canvas.width=1400; canvas.height=800; const ctx=canvas.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0); const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download=(MACHINE.name||'machine')+'.png'; a.click(); URL.revokeObjectURL(url); }; img.src=url; });

dom.printSolutionBtn.addEventListener('click', ()=>{ const serializer=new XMLSerializer(); const svgStr = serializer.serializeToString(svg); const win = window.open('','_blank'); win.document.write('<html><head><title>Solution Print</title></head><body>'); win.document.write('<h2>Machine: '+(MACHINE.name||'unnamed')+'</h2>'); win.document.write('<pre>'+escapeHtml(stepLog.textContent)+'</pre>'); win.document.write(svgStr); win.document.write('</body></html>'); win.document.close(); win.print(); });

function escapeHtml(s){ return s.replace(/[&<>"']/g, (m)=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

/* -----------------------------
   Practice bank (10+ per difficulty) with visual solutions
   ----------------------------- */

/* -----------------------------
   Practice generator (auto-generate large unique bank per session)
   ----------------------------- */
function shuffleArray(a){
  for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}
  return a;
}
function generateProblemSets(){
  const simpleSet = new Set();
  const mediumSet = new Set();
  const complexSet = new Set();

  // Simple problems: endings, exact counts, parity, modular counts
  const alphBin = ['0','1'];
  const alphAB = ['a','b'];
  const endings = ['0','1','00','11','01','10'];
  endings.forEach(e=> simpleSet.add("Strings ending with '"+e+"' over {0,1}"));
  ['even length','odd length'].forEach(x=> simpleSet.add("Strings of "+x));
  // exact count variations
  for(let k=0;k<40;k++){
    simpleSet.add("Strings with exactly "+k+" '1' (alphabet {0,1})");
    simpleSet.add("Strings with exactly "+k+" '0' (alphabet {0,1})");
  }
  // modular counts
  for(let m=2;m<=12;m++){
    for(let r=0;r<m;r++){
      simpleSet.add("Strings where number of 1's ≡ "+r+" (mod "+m+")");
      simpleSet.add("Strings where number of 0's ≡ "+r+" (mod "+m+")");
    }
  }
  // small substring checks
  const smallSubs = ['0','1','01','10','00','11','101','010'];
  smallSubs.forEach(s=> simpleSet.add("Strings containing substring '"+s+"'"));

  // Medium problems: start/end conditions, at least/at most counts, substring patterns
  ['start with 0','start with 1','end with 01','end with 10','contain 101','contain 010'].forEach(s=> mediumSet.add("Strings that "+s));
  for(let k=1;k<=40;k++){
    mediumSet.add("Strings with at least "+k+" '1's (alphabet {0,1})");
    mediumSet.add("Strings with at most "+k+" '1's (alphabet {0,1})");
    mediumSet.add("Strings with at least "+k+" 'a's (alphabet {a,b})");
    mediumSet.add("Strings with at most "+k+" 'a's (alphabet {a,b})");
  }
  // modular and position-based
  for(let m=3;m<=15;m++){
    for(let r=0;r<m;r++){
      mediumSet.add("Strings where number of a's ≡ "+r+" (mod "+m+")");
    }
  }
  // regex style prompts
  const regexMedium = ['(ab)*','(a|b)*abb','(a|b)*ba(a|b)*','(a|b){3}abb'];
  regexMedium.forEach(r=> mediumSet.add("Design an NFA for regex "+r));

  // Complex problems: palindromes up to length, equal counts, differences, advanced modulars, regex conversions
  complexSet.add("Strings that are palindromes over {0,1} of length ≤ 8");
  complexSet.add("Strings with equal number of 0's and 1's");
  complexSet.add("Strings where #0 = #1 + 1");
  complexSet.add("Design DFA for numbers divisible by 7 (binary)");
  complexSet.add("Design minimal DFA for multiples of 5 (binary)");
  complexSet.add("Construct NFA for (ab|ba)* and convert to DFA then minimize");
  complexSet.add("Given regex with nested Kleene stars, build NFA via Thompson and convert to DFA");
  for(let k=2;k<=30;k++){
    complexSet.add("Strings where difference (#0 - #1) = "+k);
    complexSet.add("Strings where total length ≡ "+(k%7)+" (mod 7)");
  }
  for(let m=4;m<=14;m++){
    for(let r=0;r<m;r++){
      complexSet.add("Strings where total length ≡ "+r+" (mod "+m+")");
    }
  }

  // convert sets to arrays and ensure minimum size by generating parameterized variations
  const simple = Array.from(simpleSet);
  const medium = Array.from(mediumSet);
  const complex = Array.from(complexSet);

  // Add parameterized problems to reach 120 each if needed
  function ensureCount(arr, target, bucketName){
    let i=0;
    while(arr.length < target){
      arr.push(bucketName + " parametric problem #" + (++i));
    }
    return arr;
  }
  shuffleArray(simple); shuffleArray(medium); shuffleArray(complex);
  ensureCount(simple, 120, "Simple");
  ensureCount(medium, 120, "Medium");
  ensureCount(complex, 120, "Complex");

  return { simple: simple.slice(0,120), medium: medium.slice(0,120), complex: complex.slice(0,120) };
}

let PRACTICE_PROBLEMS = generateProblemSets();
let PRACTICE_IDX = { simple:0, medium:0, complex:0 };

function getNextPractice(level){
  if(!PRACTICE_PROBLEMS[level] || PRACTICE_IDX[level] >= PRACTICE_PROBLEMS[level].length) return null;
  const id = PRACTICE_IDX[level] + 1;
  const q = PRACTICE_PROBLEMS[level][PRACTICE_IDX[level]];
  PRACTICE_IDX[level]++;
  return { id, q };
}
function resetPracticeSets(){
  PRACTICE_PROBLEMS = generateProblemSets();
  PRACTICE_IDX = { simple:0, medium:0, complex:0 };
  showMessage('Practice problems reset','success');
}

dom.genPracticeBtn.addEventListener('click', ()=>{
  const lvl = dom.practiceDifficulty.value || 'simple';
  const p = getNextPractice(lvl);
  if (!p){ dom.practiceBox.innerHTML = '<b>No more unique problems.</b> Click Reset to reshuffle.'; showMessage('No more unique problems in this category','error'); return; }
  dom.practiceBox.innerHTML = `<div style="font-weight:700">Problem ${p.id} (${lvl})</div><div style="margin-top:8px">${p.q}</div><div style="margin-top:10px"><button id="copyQ">Copy Q</button> <button id="loadPracticeBtn">Load example (if available)</button></div>`;
  setTimeout(()=>{
    const copyBtn = document.getElementById('copyQ');
    if (copyBtn) copyBtn.addEventListener('click', ()=>{ navigator.clipboard && navigator.clipboard.writeText(p.q).then(()=>showMessage('Question copied','success')); });
    const loadBtn = document.getElementById('loadPracticeBtn');
    if (loadBtn) loadBtn.addEventListener('click', ()=>{ showMessage('No demo machine available for generated problems','error'); });
  },60);
});
document.getElementById('resetPracticeBtn') && document.getElementById('resetPracticeBtn').addEventListener('click', ()=>{ resetPracticeSets(); });



dom.showSolutionBtn.addEventListener('click', ()=>{ // attempt automated solution path
  if (MACHINE.type==='ENFA'){ enfaToDfaAnimated(); setTimeout(()=>minimizeDFA_Hopcroft(), 600); return; }
  if (MACHINE.type==='NFA'){ nfaToDfaAnimated(); setTimeout(()=>minimizeDFA_Hopcroft(), 600); return; }
  if (MACHINE.type==='DFA'){ minimizeDFA_Hopcroft(); return; }
  showMessage('Load a practice machine or pick one with an example','error');
});

/* -----------------------------
   Wire-up basic UI actions
   ----------------------------- */
dom.modeSelect.addEventListener('change', ()=>{ MACHINE.type = dom.modeSelect.value; const ok = enforceModeStrict(); if (!ok) showMessage('Mode enforcement cancelled','error'); renderAll(); });
dom.addStateBtn.addEventListener('click', ()=>{ const id = dom.stateIdInput.value.trim(); addStateAt(id||null); dom.stateIdInput.value=''; });
dom.addTransBtn.addEventListener('click', ()=>{ addTransition(dom.fromInput.value.trim(), dom.toInput.value.trim(), dom.symbolInput.value.trim()); dom.fromInput.value=''; dom.toInput.value=''; dom.symbolInput.value=''; });
dom.setInitialBtn.addEventListener('click', ()=>{ const id = prompt('Set initial state id'); if (id) setInitial(id); });
dom.toggleAcceptBtn.addEventListener('click', ()=>{ const id = prompt('Toggle accepting on state id'); if (id) toggleAccept(id); });
dom.deleteStateBtn.addEventListener('click', ()=>{ const id = prompt('Delete which state?'); if (id) deleteState(id); });
dom.autoLayoutBtn.addEventListener('click', autoLayout);
dom.undoBtn.addEventListener('click', doUndo);
dom.redoBtn.addEventListener('click', doRedo);
dom.nfaToDfaBtn.addEventListener('click', nfaToDfaAnimated);
dom.enfaToDfaBtn.addEventListener('click', enfaToDfaAnimated);
dom.minimizeBtn.addEventListener('click', minimizeDFA_Hopcroft);

/* Download current snapshot as HTML */
dom.downloadBtn.addEventListener('click', ()=>{ try{ const content = '<!doctype html>\n' + document.documentElement.outerHTML; const blob = new Blob([content], {type:'text/html'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'advanced_dfa_studio_complete_v2.html'; a.click(); URL.revokeObjectURL(url); showMessage('Download started','success'); }catch(e){ showMessage('Download failed: '+e.message,'error'); } });

/* -----------------------------
   Closure select update & seed example
   ----------------------------- */
  /* -----------------------------
   Zoom controls for canvas
   ----------------------------- */
let currentZoom = 100;

function applyZoom() {
  svg.style.transform = `scale(${currentZoom/100})`;
  svg.style.transformOrigin = "center center";
}

dom.zoomSlider = document.getElementById('zoomSlider');
dom.zoomInBtn = document.getElementById('zoomInBtn');
dom.zoomOutBtn = document.getElementById('zoomOutBtn');
dom.zoomResetBtn = document.getElementById('zoomResetBtn');

dom.zoomSlider.addEventListener('input', () => {
  currentZoom = parseInt(dom.zoomSlider.value, 10);
  applyZoom();
});

dom.zoomInBtn.addEventListener('click', () => {
  currentZoom = Math.min(currentZoom + 10, 200);
  dom.zoomSlider.value = currentZoom;
  applyZoom();
});

dom.zoomOutBtn.addEventListener('click', () => {
  currentZoom = Math.max(currentZoom - 10, 50);
  dom.zoomSlider.value = currentZoom;
  applyZoom();
});

dom.zoomResetBtn.addEventListener('click', () => {
  currentZoom = 100;
  dom.zoomSlider.value = 100;
  applyZoom();
});

applyZoom();

function updateClosureSelect(){ dom.closureStateSelect.innerHTML=''; MACHINE.states.forEach(s=>{ const opt=document.createElement('option'); opt.value=s.id; opt.textContent=s.id; dom.closureStateSelect.appendChild(opt); }); }
function seedExample(){
  MACHINE = {
    name:'Seed ε-NFA with closure demo',
    type:'ENFA',
    states:[
      {id:'q0',x:200,y:350,initial:true,accepting:false},
      {id:'q1',x:480,y:250,initial:false,accepting:false},
      {id:'q2',x:760,y:350,initial:false,accepting:false},
      {id:'q3',x:1040,y:250,initial:false,accepting:true}
    ],
    transitions:[
      {from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q3',symbol:'a'},{from:'q0',to:'q2',symbol:'ε'}
    ],
    alphabet:['a','b']
  };
  pushUndo(); renderAll();
}
seedExample();
/* -----------------------------
   Touch/Mouse Drag-to-Create Transition
   ----------------------------- */
let transitionDrag = null;
let dragLine = null;

function startTransitionDrag(ev) {
  // Only start if tapping a state circle
  const g = ev.target.closest('g');
  if (!g || !g.hasAttribute('data-id')) return;
  const fromId = g.getAttribute('data-id');
  transitionDrag = { from: fromId };

  const pt = svg.createSVGPoint();
  pt.x = ev.clientX;
  pt.y = ev.clientY;
  const coords = pt.matrixTransform(svg.getScreenCTM().inverse());

  // Make a dashed preview line
  dragLine = createSVG('line', {
    x1: coords.x, y1: coords.y,
    x2: coords.x, y2: coords.y,
    stroke: '#2563eb',
    'stroke-dasharray': '4,2',
    'stroke-width': '2'
  });
  overlay.appendChild(dragLine);

  svg.addEventListener('pointermove', previewTransitionDrag);
  svg.addEventListener('pointerup', endTransitionDrag);
}

function previewTransitionDrag(ev) {
  if (!dragLine) return;
  const pt = svg.createSVGPoint();
  pt.x = ev.clientX;
  pt.y = ev.clientY;
  const coords = pt.matrixTransform(svg.getScreenCTM().inverse());
  dragLine.setAttribute('x2', coords.x);
  dragLine.setAttribute('y2', coords.y);
}

function endTransitionDrag(ev) {
  if (dragLine) {
    overlay.removeChild(dragLine);
    dragLine = null;
  }

  svg.removeEventListener('pointermove', previewTransitionDrag);
  svg.removeEventListener('pointerup', endTransitionDrag);

  if (!transitionDrag) return;

  const target = ev.target.closest('g');
  if (target && target.hasAttribute('data-id')) {
    const toId = target.getAttribute('data-id');
    if (toId && toId !== transitionDrag.from) {
      const sym = prompt(`Enter symbol(s) for transition ${transitionDrag.from} → ${toId}`);
      if (sym) addTransition(transitionDrag.from, toId, sym);
    }
  }
  transitionDrag = null;
}
/* -----------------------------
   Move States + Rename Support
   ----------------------------- */
let movingState = null;

function startMoveState(ev, id) {
  ev.preventDefault();
  const state = MACHINE.states.find(s => s.id === id);
  if (!state) return;

  dragging = {
    id: id,
    startX: ev.clientX,   // ✅ store initial pointer position
    startY: ev.clientY,
    offsetX: state.x - ev.clientX,
    offsetY: state.y - ev.clientY
  };
  pointerIdActive = ev.pointerId;

  svg.setPointerCapture(ev.pointerId);
  svg.addEventListener("pointermove", statePointerMove);
  svg.addEventListener("pointerup", statePointerUp);
  svg.addEventListener("pointercancel", statePointerUp);
}

function moveStateDrag(ev) {
  if (!movingState) return;

  const pt = svg.createSVGPoint();
  pt.x = ev.clientX;
  pt.y = ev.clientY;
  const coords = pt.matrixTransform(svg.getScreenCTM().inverse());

  const state = MACHINE.states.find(s => s.id === movingState.id);
  if (state) {
    state.x = coords.x;
    state.y = coords.y;
    renderAll();
  }
}

function endMoveState(ev) {
  svg.removeEventListener('pointermove', moveStateDrag);
  svg.removeEventListener('pointerup', endMoveState);

  if (movingState) {
    // If it was just a tap (not a drag), allow rename
    if (Math.abs(ev.movementX) < 3 && Math.abs(ev.movementY) < 3) {
      const state = MACHINE.states.find(s => s.id === movingState.id);
      if (state) {
        const newName = prompt("Enter new name for state:", state.label || state.id);
        if (newName && newName.trim()) {
          state.label = newName.trim();
          renderAll();
        }
      }
    }
  }
  movingState = null;
}
/* ===== Transition Selection Logic ===== */


let selectedState = null;

function handleTransitionClick(stateId) {
  if (!selectedState) {
    // first selection
    selectedState = stateId;
    highlightState(stateId, true);
  } else {
    // second selection
    const from = selectedState;
    const to = stateId;
    highlightState(from, false);
    selectedState = null;

    // open modal instead of prompt
    openTransitionModal(from, to);
  }
}


function highlightState(id, active) {
  const circle = document.querySelector(`.state-circle[data-id="${id}"]`);
  if (circle) {
    if (active) {
      circle.classList.add("highlighted");
    } else {
      circle.classList.remove("highlighted");
    }
  }
}


function deleteState(id) {
  // Remove state
  MACHINE.states = MACHINE.states.filter(s => s.id !== id);
  // Remove transitions linked to it
  MACHINE.transitions = MACHINE.transitions.filter(t => t.from !== id && t.to !== id);
  renderAll();
}

function deleteTransition(id) {
  MACHINE.transitions = MACHINE.transitions.filter(t => t.id !== id);
  renderAll();
}
/* === Rename Modal Logic === */
// === Rename Modal Logic ===
let renameTarget = null;

function openRenameModal(state) {
  renameTarget = state;
  document.getElementById('renameInput').value = state.id;
  document.getElementById('renameModal').style.display = 'flex';
}

document.getElementById('renameCancel').addEventListener('click', () => {
  document.getElementById('renameModal').style.display = 'none';
  renameTarget = null;
});

document.getElementById('renameSave').addEventListener('click', () => {
  const newId = document.getElementById('renameInput').value.trim();
  if (renameTarget && newId && newId !== renameTarget.id) {
    renameState(renameTarget.id, newId);
  }
  document.getElementById('renameModal').style.display = 'none';
  renameTarget = null;
});

/* === Transition Modal Logic === */
let transitionFrom = null;
let transitionTo = null;

function openTransitionModal(from, to) {
  transitionFrom = from;
  transitionTo = to;

  document.getElementById("transitionText").textContent =
    `Add transition: ${from} → ${to}`;
  document.getElementById("transitionInput").value = "";
  document.getElementById("transitionModal").style.display = "flex";
}

function closeTransitionModal() {
  document.getElementById("transitionModal").style.display = "none";
  transitionFrom = null;
  transitionTo = null;
}

document.getElementById("transitionCancel").addEventListener("click", closeTransitionModal);

document.getElementById("transitionSave").addEventListener("click", () => {
  const sym = document.getElementById("transitionInput").value.trim();
  if (transitionFrom && transitionTo && sym) {
    addTransition(transitionFrom, transitionTo, sym);
    renderAll();
  }
  closeTransitionModal();
});

/* -----------------------------
   Initial render
   ----------------------------- */
renderAll(); showMessage('Ready — load a practice example or build your own','info');

</script>
<!-- Rename State Modal -->




</body>
</html>
