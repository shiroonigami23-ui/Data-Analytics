<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0f172a">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Finite Automata Practice — Enhanced Interactive Studio</title>
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<style>
:root{--bg1:linear-gradient(135deg,#0f172a 0%, #0b1220 100%);--panel-bg: rgba(255,255,255,0.98);--accent1:#667eea;--accent2:#764ba2;--muted:#94a3b8;--success:#38a169;--danger:#e53e3e}
*{box-sizing:border-box}html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg1);color:#0b1220;-webkit-font-smoothing:antialiased}
.app-container{max-width:1400px;margin:12px auto;padding:18px;display:flex;flex-direction:column;gap:14px}
.header {background:linear-gradient(90deg,var(--accent1),var(--accent2));padding:8px 14px;border-radius:12px;color:#fff;box-shadow:0 6px 20px rgba(2,6,23,0.4);display:flex;flex-direction:column;gap:4px}
.main-content{display:grid;grid-template-columns: minmax(200px,260px) 1fr;gap:20px;align-items:start}
@media(max-width:1024px){.main-content{grid-template-columns:1fr;grid-auto-rows:auto} .control-panel{position:relative;max-height:none} .visualization-panel{position:relative}}
.control-panel{background:var(--panel-bg);border-radius:14px;padding:18px;border:1px solid rgba(255,255,255,0.12);backdrop-filter:blur(6px);max-height:calc(100vh - 160px);overflow:auto;position:sticky;top:20px}
.section-title{font-size:1.05rem;margin-bottom:12px;color:#111827;display:flex;align-items:center;gap:10px}
.icon-btn{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:10px;border:1px solid rgba(2,6,23,0.06);background:#fff;cursor:pointer;font-weight:600}
.toolbar-icon{display:inline-flex;align-items:center;justify-content:center;width:46px;height:46px;border-radius:10px;border:1px solid rgba(0,0,0,0.06);background:linear-gradient(180deg,#fff,#f7fafc);cursor:pointer;font-size:20px;transition: transform 0.2s, box-shadow 0.2s;}
.toolbar-icon.active{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#fff;box-shadow:0 6px 18px rgba(99,102,241,0.18);transform:translateY(-2px)}
.toolbar-icon:hover {transform: scale(1.15);box-shadow: 0 4px 12px rgba(0,0,0,0.15);}
.visualization-panel{background:var(--panel-bg);border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.12);display:flex;flex-direction:column;gap:12px;max-height:calc(100vh - 160px);overflow:hidden;position:sticky;top:20px}
.canvas-wrapper{background:#fff;border-radius:12px;padding:12px;border:1px solid #e6eef8;flex:1;min-height:420px;display:flex;flex-direction:column}
.canvas-toolbar { display:flex; gap:8px; margin-bottom:8px; position: sticky; top: 0; z-index: 30; background: linear-gradient(180deg,#ffffff,#fbfdff); padding: 8px; box-shadow: 0 6px 18px rgba(0,0,0,0.06); border-bottom: 1px solid rgba(0,0,0,0.04); position: relative; }
.canvas-area{flex:1;display:flex;gap:12px;align-items:flex-start;overflow:auto;}
.svg-canvas{flex:1;min-height:360px;border-radius:10px;border:1px dashed #e6eef8;overflow:auto;padding:8px;background:linear-gradient(180deg,#ffffff,#fbfdff)}
#dfaSVG{width:100%;height:650px;min-width:900px;min-height:540px;display:block}
.zoom-controls{width:60px;display:flex;flex-direction:column;align-items:center;gap:10px}
.zoom-controls button{all:unset;}
.zoom-controls .toolbar-icon{width:40px;height:40px;margin:2px;}
.test-panel{display:flex;gap:12px;align-items:center}
.input{flex:1;display:flex;gap:8px}
.input input{flex:1;padding:10px;border-radius:10px;border:1px solid #e6eef8}
.run-btn{padding:10px 12px;border-radius:10px;border:none;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#fff;cursor:pointer;font-weight:700}
.output-display{padding:12px;border-radius:10px;border:1px solid #eef2ff;background:linear-gradient(90deg,#f8fafc,#fff);font-weight:700;text-align:center}
.state-circle{fill:#fff;stroke:var(--accent1);stroke-width:3;cursor:pointer}
.state-label{font-weight:700;fill:#0b1220;text-anchor:middle;dominant-baseline:central;font-size:14px}
.transition-path{fill:none;stroke:var(--accent1);stroke-width:2;marker-end:url(#arrowhead)}
.transition-label{font-weight:700;fill:#0b1220;text-anchor:middle;font-size:13px}
.kv{font-size:13px;color:var(--muted)}
.footer-note{font-size:12px;color:var(--muted);text-align:center;margin-top:8px}
.canvas-wrapper::-webkit-scrollbar{height:10px;width:10px}
.canvas-wrapper::-webkit-scrollbar-thumb{background:linear-gradient(90deg,var(--accent1),var(--accent2));border-radius:10px}

@keyframes pulseState {
  0%   { stroke-width: 3; stroke: gold; }
  50%  { stroke-width: 8; stroke: orange; }
  100% { stroke-width: 3; stroke: gold; }
}
@keyframes pulseTransition {
  0%   { stroke-width: 2; stroke: gold; }
  50%  { stroke-width: 6; stroke: orange; }
  100% { stroke-width: 2; stroke: gold; }
}
.state-animating {
  animation-name: pulseState;
  animation-timing-function: ease-in-out;
  animation-fill-mode: forwards;
}
.transition-animating {
  animation-name: pulseTransition;
  animation-timing-function: ease-in-out;
  animation-fill-mode: forwards;
}

@keyframes drawState {
  0%   { opacity: 0; transform: scale(0); }
  60%  { opacity: 1; transform: scale(1.15); }
  100% { opacity: 1; transform: scale(1); }
}
@keyframes drawTransition {
  0%   { stroke-dashoffset: 1000; opacity: 0; }
  100% { stroke-dashoffset: 0; opacity: 1; }
}
.state-drawing {
  animation: drawState 0.6s ease-out forwards;
  transform-origin: center;
}
.transition-drawing {
  stroke-dasharray: 1000;
  animation: drawTransition 0.8s ease-out forwards;
}

.state-selected {
  stroke: yellow !important;
  stroke-width: 6 !important;
  filter: drop-shadow(0 0 6px gold);
}

.initial-arrow {
  stroke: black !important;
  stroke-width: 3 !important;
  marker-end: url(#arrowhead);
}

#zoomSlider {
  writing-mode: bt-lr;
  -webkit-appearance: slider-vertical;
  width: 8px;
  height: 120px;
}

.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 200;
}
.modal-box {
  background: var(--panel-bg);
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.25);
  min-width: 240px;
  max-width: 320px;
  animation: popIn 0.2s ease;
}
.modal-title {
  font-weight: bold;
  margin-bottom: 8px;
}

.modal-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}
@keyframes popIn {
  from { transform: scale(0.9); opacity:0; }
  to { transform: scale(1); opacity:1; }
}

.modal-input {
  width: 100%;
  padding: 6px;
  margin-bottom: 12px;
  border: 2px solid #00bcd4;
  border-radius: 6px;
  background: #e0f7fa;
  outline: none;
  transition: 0.2s;
}
.modal-input:focus {
  border-color: #00838f;
  background: #b2ebf2;
  box-shadow: 0 0 6px rgba(0, 188, 212, 0.7);
}

.header h1 {font-size:1.2rem;margin:0;}
.header p { font-size: 0.9rem; margin: 2px 0 0 0; }

.final-ring {
  fill: none;
  stroke: #ff9800;
  stroke-width: 4;
  filter: drop-shadow(0 0 8px rgba(255,152,0,0.7));
  vector-effect: non-scaling-stroke;
}

@keyframes finalGlow {
  0%   { stroke-width: 3; stroke: #ff9800; filter: drop-shadow(0 0 4px rgba(255,152,0,0.6)); }
  50%  { stroke-width: 6; stroke: gold; filter: drop-shadow(0 0 12px rgba(255,215,0,0.9)); }
  100% { stroke-width: 3; stroke: #ff9800; filter: drop-shadow(0 0 4px rgba(255,152,0,0.6)); }
}

@keyframes initialArrowPulse {
  0%   { stroke-width: 2; stroke: dodgerblue; filter: drop-shadow(0 0 4px rgba(30,144,255,0.6)); }
  50%  { stroke-width: 5; stroke: #00bfff; filter: drop-shadow(0 0 10px rgba(0,191,255,0.9)); }
  100% { stroke-width: 2; stroke: dodgerblue; filter: drop-shadow(0 0 4px rgba(30,144,255,0.6)); }
}
@keyframes ripple {
  0%   { r: 36; opacity: 0.7; stroke-width: 2; }
  70%  { r: 50; opacity: 0; stroke-width: 1; }
  100% { r: 50; opacity: 0; stroke-width: 1; }
}
.anim-final-ring {
  animation: finalGlow 3s ease-in-out infinite;
  transform-origin: center;
}
.anim-initial-arrow {
  animation: initialArrowPulse 2.5s ease-in-out infinite;
}

@keyframes finalInnerGlow {
  0%   { stroke: var(--accent1); filter: drop-shadow(0 0 2px rgba(255,152,0,0.3)); }
  50%  { stroke: var(--accent1); filter: drop-shadow(0 0 6px rgba(255,215,0,0.5)); }
  100% { stroke: var(--accent1); filter: drop-shadow(0 0 2px rgba(255,152,0,0.3)); }
}
.anim-final-inner {
  animation: finalInnerGlow 3s ease-in-out infinite;
}

.control-section { margin-top: 8px; }
.control-row { display: flex; gap: 6px; margin: 4px 0; }
.control-row button { flex: 1; padding: 6px; border-radius: 6px; border: none; background: var(--accent2); color: #fff; cursor: pointer; }
.control-row button:hover { opacity: 0.85; }

.validation-box {
  background: #fff;
  border: 1px solid #ccc;
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 14px;
  opacity: 0;
  transform: translateY(-4px);
  transition: opacity 0.3s ease, transform 0.3s ease;
  z-index: 300;
  position: absolute;
}
.validation-box.show {
  opacity: 1;
  transform: translateY(0);
}

#stepLog {
  max-height: 10em;
  overflow-y: auto;
  border-radius: 8px;
  padding: 8px 12px;
  font-family: monospace;
  font-size: 0.9em;
  background: linear-gradient(180deg, #1e293b, #0f172a);
  color: #f8fafc;
  box-shadow: inset 0 0 6px rgba(0,0,0,0.4);
}

#stepLog div {
  padding: 4px 6px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  display: flex;
  align-items: center;
  gap: 6px;
  opacity: 0.9;
}

#stepLog div:last-child { border-bottom: none; }
#stepLog i { color: #38bdf8; }

@keyframes glowIn {
  0%   { background: rgba(220,38,38,0.3); box-shadow: 0 0 10px rgba(220,38,38,0.9); color: #fca5a5; }
  60%  { background: rgba(220,38,38,0.15); box-shadow: 0 0 5px rgba(220,38,38,0.6); color: #fecaca; }
  100% { background: transparent; box-shadow: none; color: #f8fafc; }
}

#stepLog div.new-log {
  animation: glowIn 1.4s ease-out;
}


@keyframes initialGlow {
  0%   { stroke: skyblue; stroke-width: 3; opacity: 0.3; }
  50%  { stroke: skyblue; stroke-width: 5; opacity: 0.8; }
  100% { stroke: skyblue; stroke-width: 3; opacity: 0.3; }
}
.state-circle.initial-glow {
  animation: initialGlow 2s infinite;
}

@keyframes initialStatePulse {
  0%   { stroke: skyblue; stroke-width: 3; filter: drop-shadow(0 0 4px rgba(135,206,250,0.6)); }
  50%  { stroke: deepskyblue; stroke-width: 6; filter: drop-shadow(0 0 12px rgba(30,144,255,0.9)); }
  100% { stroke: skyblue; stroke-width: 3; filter: drop-shadow(0 0 4px rgba(135,206,250,0.6)); }
}
.state-circle.initial-pulse {
  animation: initialStatePulse 2s ease-in-out infinite;
}
</style>
</head>
<body>

<div id="splashScreen" style="
  position:fixed;inset:0;
  display:flex;align-items:center;justify-content:center;
  background:linear-gradient(135deg,#667eea,#764ba2);
  z-index:9999;flex-direction:column;gap:20px;color:#fff;
">
  <h1 id="splashTitle" style="font-size:3.5rem;margin:0;text-shadow:0 4px 12px rgba(0,0,0,0.4);cursor:pointer;">
    Finite Automata
  </h1>
</div>

<div id="mainApp" style="display:none">

<div class="app-container" role="application" aria-label="Finite Automata Practice Studio">
  <header class="header">
    <h1>Finite Automata Practice — Enhanced Interactive Studio</h1>
    <p>Create, validate, and test DFA, NFA, and ε-NFA with step-by-step animation</p>
  </header>

  <main class="main-content">
    <aside class="control-panel" aria-label="Controls">
      <div class="section-title">⚙️ Mode & Interaction</div>
      <div style="display:flex;gap:8px;margin-bottom:12px">
        <select id="modeSelect" aria-label="Mode select" style="flex:1;padding:10px;border-radius:10px;border:1px solid #e6eef8">
          <option value="DFA">DFA</option>
          <option value="NFA">NFA</option>
          <option value="ENFA">ε-NFA</option>
        </select>
      </div>

      <details class="control-section" open>
        <summary style="cursor:pointer; font-weight:600; color:#374151; background:linear-gradient(90deg,#fff,#f7fafc); padding:6px 8px; border-radius:8px;">🧩 Practice Generator</summary>
        <div style="padding:8px 6px;">
          <div style="margin-bottom:12px">
            <div style="display:flex;gap:8px">
              <select id="practiceMode" style="flex:1;padding:10px;border-radius:10px;border:1px solid #e6eef8">
                <option value="basic">Basic</option>
                <option value="medium">Medium</option>
                <option value="easy">Easy</option>
              </select>
              <button class="icon-btn" id="genPracticeBtn">Generate</button>
            </div>
            <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
              <button class="icon-btn" id="showSolBtn">Show Solution</button>
              <button class="icon-btn" id="resetPractice">Reset</button>
              <button class="icon-btn" id="checkAnswerBtn">Check Answer</button>
            </div>
            <div style="margin-top:10px;padding:10px;border-radius:10px;background:linear-gradient(180deg,#fff,#fbfdff);border:1px solid #eef2ff;min-height:120px" id="practiceBox">No practice generated yet.</div>
          </div>
        </div>
      </details>

      <details class="control-section">
        <summary style="cursor:pointer; font-weight:600; color:#374151; background:linear-gradient(90deg,#fff,#f7fafc); padding:6px 8px; border-radius:8px;">🧪 Testing</summary>
        <div style="padding:8px 6px;">
          <div class="controls-group">
            <div class="test-panel">
              <div class="input"><input id="testInput" placeholder="Enter string (e.g., abbab)" /></div>
              <button id="runTestBtn" class="run-btn">Run</button>
            </div>

            <div id="randomStringBox" style="margin:6px 0; font-size:0.9em; background:linear-gradient(90deg,#fff,#f7fafc); padding:6px 8px; border-radius:8px;">
              🎲 <button id="genRandBtn" class="icon-btn">Random</button>
            </div>

            <details id="testOptionsCollapse" style="margin:6px 0; font-size:0.9em;">
              <summary style="cursor:pointer; font-weight:600; color:#374151; background:linear-gradient(90deg,#fff,#f7fafc); padding:6px 8px; border-radius:8px;">⚙️ Simulation Options</summary>
              <div id="testOptions" style="padding:8px 6px;">
                <label style="margin-right:8px;"><input type="radio" name="simMode" value="auto" checked> Auto</label>
                <label style="margin-right:8px;"><input type="radio" name="simMode" value="manual"> Manual</label>
                <label style="display:inline-flex;align-items:center;gap:6px;">Speed:
                  <select id="testSpeed" style="margin-left:6px;padding:6px;border-radius:6px;border:1px solid #e6eef8">
                    <option value="500">Fast</option>
                    <option value="1000">Normal</option>
                    <option value="2000" selected>Slow</option>
                  </select>
                </label>
                <div id="manualButtons" style="display:none;margin-top:8px;display:flex;gap:6px;">
                  <button id="stepPrev" class="icon-btn">◀ Prev</button>
                  <button id="stepNext" class="icon-btn">Next ▶</button>
                  <button id="stepReset" class="icon-btn">⟲ Reset</button>
                </div>
              </div>
            </details>
            <div style="margin-top:8px" id="testOutput" class="output-display">Ready</div>
          </div>
        </div>
      </details>

      <details class="control-section">
        <summary style="cursor:pointer; font-weight:600; color:#374151; background:linear-gradient(90deg,#fff,#f7fafc); padding:6px 8px; border-radius:8px;">📁 File</summary>
        <div class="control-row">
          <button id="saveMachineBtn" title="Save machine (JSON)">💾 Save</button>
          <button id="loadMachineBtn" title="Load machine (JSON)">📂 Load</button>
        </div>
        <div class="control-row">
          <button id="exportPngBtn" title="Export canvas as PNG">🖼️ Export PNG</button>
        </div>
        <input type="file" id="loadFileInput" accept=".json" style="display:none"/>
      </details>
    </aside>

    <section class="visualization-panel" aria-label="Visualization">
      <div class="visualization-header" style="display:flex;align-items:center;gap:12px;">
        <div style="flex:1"><strong>Automata Visualization</strong><div class="kv">Mode: <span id="modeLabel">DFA</span></div></div>
      </div>

      <div class="canvas-wrapper" id="canvasWrapper">
        <div class="canvas-top">
          <div class="canvas-toolbar" role="toolbar" aria-label="Canvas toolbar">
            <div class="toolbar-icon" id="tool-addclick" title="Add state on canvas click" data-mode="addclick"><i data-lucide="plus-circle" style="color:#4caf50"></i></div>
            <div class="toolbar-icon" id="tool-move" title="Move states" data-mode="move"><i data-lucide="move" style="color:#2196f3"></i></div>
            <div class="toolbar-icon" id="tool-transition" title="Add transition" data-mode="transition"><i data-lucide="git-branch" style="color:#9c27b0"></i></div>
            <div class="toolbar-icon" id="tool-rename" title="Rename state" data-mode="rename"><i data-lucide="edit-3" style="color:#009688"></i></div>
            <div class="toolbar-icon" id="tool-delete" title="Delete state/transition" data-mode="delete"><i data-lucide="trash-2" style="color:#f44336"></i></div>
            <div class="toolbar-icon" id="tool-stateprops" title="Set state properties" data-mode="stateprops"><i data-lucide="settings" style="color:#607d8b"></i></div>
            <button id="validateBtn" class="toolbar-icon" title="Validate Automaton" style="margin-left:8px"><i data-lucide="check-circle"></i></button>
          </div>
        </div>
        <div class="canvas-area">
          <div class="svg-canvas" id="svgWrapper" tabindex="0">
            <svg id="dfaSVG" viewBox="0 0 1400 900" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Automaton canvas">
              <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                  <polygon points="0 0, 10 3.5, 0 7" fill="#667eea" />
                </marker>
              </defs>
              <g id="edges"></g>
              <g id="states"></g>
              <text id="canvasHint" x="700" y="420" text-anchor="middle" fill="#9aa6b2" font-size="18">Tap canvas to add a state (use ➕ tool)</text>
            </svg>
          </div>
          <div class="zoom-controls">
            <button id="zoomInBtn" class="toolbar-icon" title="Zoom In"><i data-lucide="zoom-in"></i></button>
            <input id="zoomSlider" type="range" min="50" max="200" value="100" />
            <button id="zoomOutBtn" class="toolbar-icon" title="Zoom Out"><i data-lucide="zoom-out"></i></button>
            <button id="zoomResetBtn" class="toolbar-icon" title="Reset Zoom"><i data-lucide="refresh-ccw"></i></button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <div style="max-width:1400px;margin:8px auto 0 auto;padding:0 18px;">
    <div style="display:flex;gap:12px;align-items:center;margin-top:8px">
      <div style="flex:1" id="stepLog">Step log appears here.</div>
    </div>
  </div>
</div>

<div id="transitionModal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.6);align-items:center;justify-content:center;z-index:60">
  <div style="background:#fff;padding:16px;border-radius:10px;width:320px;max-width:94%;box-shadow:0 8px 30px rgba(2,6,23,0.4)">
    <h3 style="margin:0 0 10px 0">Add Transition</h3>
    <div style="display:flex;gap:8px;margin-bottom:8px">
      <input id="transFrom" placeholder="from (q0)" style="flex:1;padding:8px;border-radius:8px;border:1px solid #e6eef8" />
      <input id="transTo" placeholder="to (q1)" style="flex:1;padding:8px;border-radius:8px;border:1px solid #e6eef8" />
    </div>
    <div style="margin-bottom:10px"><input id="transSymbol" placeholder="symbol (ε for NFA/ε-NFA)" style="width:100%;padding:8px;border-radius:8px;border:1px solid #e6eef8" /></div>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="transCancel" class="icon-btn">Cancel</button>
      <button id="transSave" class="icon-btn">Save</button>
    </div>
  </div>
</div>

<div id="statePropsModal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.6);align-items:center;justify-content:center;z-index:70">
  <div style="background:#fff;padding:16px;border-radius:10px;width:300px;max-width:94%;box-shadow:0 8px 30px rgba(2,6,23,0.4)">
    <h3 style="margin:0 0 10px 0">State Properties</h3>
    <label style="display:block;margin-bottom:8px">
      <input type="checkbox" id="propInitial"> Initial
    </label>
    <label style="display:block;margin-bottom:12px">
      <input type="checkbox" id="propFinal"> Final
    </label>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="propCancel" class="icon-btn">Cancel</button>
      <button id="propSave" class="icon-btn">Save</button>
    </div>
  </div>
</div>

<script src="https://unpkg.com/lucide@latest"></script>
<script>

function getLoopPathAndLabel(cx, cy, r, states, id, symbol) {
  const loopRadius = 40;
  const dirs = [
    { dx: 0, dy: -1 }, // top
    { dx: 1, dy: 0 },  // right
    { dx: 0, dy: 1 },  // bottom
    { dx: -1, dy: 0 }  // left
  ];

  for (let d of dirs) {
    const checkX = cx + d.dx * (r + loopRadius);
    const checkY = cy + d.dy * (r + loopRadius);

    let safe = true;
    for (let s of states) {
      if (s.id === id) continue;
      if (Math.hypot(s.x - checkX, s.y - checkY) < r * 2) {
        safe = false;
        break;
      }
    }

    if (safe) {
      const offX = d.dx * loopRadius;
      const offY = d.dy * loopRadius;

      const pathData = `M ${cx} ${cy - r}
                        C ${cx - offX} ${cy + offY},
                          ${cx + offX} ${cy + offY},
                          ${cx} ${cy - r}`;

      const labelX = cx + d.dx * (r + loopRadius + 10);
      const labelY = cy + d.dy * (r + loopRadius + 10);

      return { pathData, labelX, labelY };
    }
  }

  // fallback top
  return {
    pathData: `M ${cx} ${cy - r}
               C ${cx - loopRadius} ${cy - r - loopRadius},
                 ${cx + loopRadius} ${cy - r - loopRadius},
                 ${cx} ${cy - r}`,
    labelX: cx,
    labelY: cy - r - loopRadius - 10
  };
}

const MODE_SELECT = document.getElementById('modeSelect');
const svg = document.getElementById('dfaSVG');
const practiceBox = document.getElementById('practiceBox');
const genPracticeBtn = document.getElementById('genPracticeBtn');
const showSolBtn = document.getElementById('showSolBtn');
const resetPractice = document.getElementById('resetPractice');
const checkAnswerBtn = document.getElementById('checkAnswerBtn');
const testInput = document.getElementById('testInput');
const testOutput = document.getElementById('testOutput');
const runTestBtn = document.getElementById('runTestBtn');
const zoomSlider = document.getElementById('zoomSlider');
const zoomInBtn = document.getElementById('zoomInBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const zoomResetBtn = document.getElementById('zoomResetBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');

let MACHINE = { type: 'DFA', states: [], transitions: [], alphabet: [] };
let CURRENT_MODE = 'addclick';
let SELECTED_STATE = null;
let TRANS_FROM = null;
let UNDO_STACK = [];
let REDO_STACK = [];
let LOG = [];

// --- added helper: stacked JFLAP-like labels (newest on top) ---
function addTransitionLabel(edgesParent, labelX, labelY, symbol, fromId, toId) {
  const svgNS = "http://www.w3.org/2000/svg";
  const spacing = 12; // px between stacked labels
  const selector = 'text.transition-label[data-from="' + fromId + '"][data-to="' + toId + '"]';
  const existing = edgesParent.querySelectorAll(selector);

  // Prevent duplicate symbols on the same edge
  for (let lbl of existing) {
    if (lbl.textContent === symbol || (lbl.textContent === 'ε' && (symbol === '' || symbol === undefined))) {
      return; // already exists → ignore
    }
  }

  // Shift old ones down
  existing.forEach(lbl => {
    const y = parseFloat(lbl.getAttribute('y')) || labelY;
    lbl.setAttribute('y', (y + spacing).toString());
  });

  // Add new on top
  const text = document.createElementNS(svgNS, 'text');
  text.setAttribute('class', 'transition-label');
  text.setAttribute('x', labelX);
  text.setAttribute('y', labelY);
  text.setAttribute('text-anchor', 'middle');
  text.setAttribute('data-from', fromId);
  text.setAttribute('data-to', toId);
  text.textContent = (symbol === '' || symbol === undefined) ? 'ε' : symbol;
  edgesParent.appendChild(text);
}
// --- end helper ---

const PRACTICE_BANK = {
  DFA: {
    basic: [
      {q:"Design a DFA that accepts strings ending with 'a' over alphabet {a,b}", sol:"States: q0(initial), q1(final). Transitions: δ(q0,a)=q1, δ(q0,b)=q0, δ(q1,a)=q1, δ(q1,b)=q0", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA that accepts strings starting with 'b' over alphabet {a,b}", sol:"States: q0(initial), q1(final), q2(dead). Transitions: δ(q0,a)=q2, δ(q0,b)=q1, δ(q1,a)=q1, δ(q1,b)=q1, δ(q2,a)=q2, δ(q2,b)=q2", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:450,y:300,accepting:true},{id:'q2',x:350,y:450}],transitions:[{from:'q0',to:'q2',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings with even number of 'a's over {a,b}", sol:"States: q0(initial,final), q1. Transitions: δ(q0,a)=q1, δ(q0,b)=q0, δ(q1,a)=q0, δ(q1,b)=q1", machine:{states:[{id:'q0',x:300,y:300,initial:true,accepting:true},{id:'q1',x:500,y:300}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q0',symbol:'a'},{from:'q1',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings containing 'ab' as substring over {a,b}", sol:"States: q0(initial), q1, q2(final). Transitions: δ(q0,a)=q1, δ(q0,b)=q0, δ(q1,a)=q1, δ(q1,b)=q2, δ(q2,a)=q2, δ(q2,b)=q2", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings with odd number of 'b's over {a,b}", sol:"States: q0(initial), q1(final). Transitions: δ(q0,a)=q0, δ(q0,b)=q1, δ(q1,a)=q1, δ(q1,b)=q0", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings ending with 'bb' over {a,b}", sol:"States: q0(initial), q1, q2(final). Transitions: δ(q0,a)=q0, δ(q0,b)=q1, δ(q1,a)=q0, δ(q1,b)=q2, δ(q2,a)=q0, δ(q2,b)=q2", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q0',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q0',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA that accepts only the string 'ab' over {a,b}", sol:"States: q0(initial), q1, q2(final), q3(dead). Transitions: δ(q0,a)=q1, δ(q0,b)=q3, δ(q1,a)=q3, δ(q1,b)=q2, δ(q2,a)=q3, δ(q2,b)=q3, δ(q3,a)=q3, δ(q3,b)=q3", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300,accepting:true},{id:'q3',x:350,y:450}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q3',symbol:'b'},{from:'q1',to:'q3',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q3',symbol:'a'},{from:'q2',to:'q3',symbol:'b'},{from:'q3',to:'q3',symbol:'a'},{from:'q3',to:'q3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings not containing 'aa' over {a,b}", sol:"States: q0(initial,final), q1(final), q2(dead). Transitions: δ(q0,a)=q1, δ(q0,b)=q0, δ(q1,a)=q2, δ(q1,b)=q0, δ(q2,a)=q2, δ(q2,b)=q2", machine:{states:[{id:'q0',x:250,y:300,initial:true,accepting:true},{id:'q1',x:450,y:300,accepting:true},{id:'q2',x:350,y:450}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q0',symbol:'b'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings with length divisible by 3 over {a,b}", sol:"States: q0(initial,final), q1, q2. Transitions: δ(q0,a)=q1, δ(q0,b)=q1, δ(q1,a)=q2, δ(q1,b)=q2, δ(q2,a)=q0, δ(q2,b)=q0", machine:{states:[{id:'q0',x:350,y:250,initial:true,accepting:true},{id:'q1',x:250,y:400},{id:'q2',x:450,y:400}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q0',symbol:'a'},{from:'q2',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings starting and ending with same symbol over {a,b}", sol:"States: q0(initial), q1, q2, q3(final), q4(final). Transitions: δ(q0,a)=q1, δ(q0,b)=q2, δ(q1,a)=q3, δ(q1,b)=q1, δ(q2,a)=q2, δ(q2,b)=q4, δ(q3,a)=q3, δ(q3,b)=q1, δ(q4,a)=q2, δ(q4,b)=q4", machine:{states:[{id:'q0',x:300,y:200,initial:true},{id:'q1',x:200,y:350},{id:'q2',x:400,y:350},{id:'q3',x:200,y:500,accepting:true},{id:'q4',x:400,y:500,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q2',symbol:'b'},{from:'q1',to:'q3',symbol:'a'},{from:'q1',to:'q1',symbol:'b'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q4',symbol:'b'},{from:'q3',to:'q3',symbol:'a'},{from:'q3',to:'q1',symbol:'b'},{from:'q4',to:'q2',symbol:'a'},{from:'q4',to:'q4',symbol:'b'}],alphabet:['a','b']}}
    ],
    medium: [
      {q:"Design a DFA for strings where #a mod 3 = 0 over {a,b}", sol:"States: q0(initial,final), q1, q2. Transitions track count of 'a' modulo 3", machine:{states:[{id:'q0',x:350,y:250,initial:true,accepting:true},{id:'q1',x:250,y:400},{id:'q2',x:450,y:400}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q1',symbol:'b'},{from:'q2',to:'q0',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings containing exactly two 'a's over {a,b}", sol:"States: q0(initial), q1, q2(final), q3(dead). Each 'a' moves forward, third 'a' goes to dead state", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300,accepting:true},{id:'q3',x:350,y:450}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q1',symbol:'b'},{from:'q2',to:'q3',symbol:'a'},{from:'q2',to:'q2',symbol:'b'},{from:'q3',to:'q3',symbol:'a'},{from:'q3',to:'q3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings with even #a and odd #b over {a,b}", sol:"States: q0(initial), q1(final), q2, q3. Track parity of both 'a' and 'b'", machine:{states:[{id:'q0',x:250,y:250,initial:true},{id:'q1',x:450,y:250,accepting:true},{id:'q2',x:250,y:450},{id:'q3',x:450,y:450}],transitions:[{from:'q0',to:'q2',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q3',symbol:'a'},{from:'q1',to:'q0',symbol:'b'},{from:'q2',to:'q0',symbol:'a'},{from:'q2',to:'q3',symbol:'b'},{from:'q3',to:'q1',symbol:'a'},{from:'q3',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings not ending with 'ab' over {a,b}", sol:"Track last two symbols. Reject only if ends with 'ab'", machine:{states:[{id:'q0',x:250,y:300,initial:true,accepting:true},{id:'q1',x:400,y:300,accepting:true},{id:'q2',x:550,y:300}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q1',symbol:'a'},{from:'q2',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings containing 'aba' as substring over {a,b}", sol:"Progressive states matching pattern 'a', 'ab', 'aba'", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300},{id:'q3',x:650,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q3',symbol:'a'},{from:'q2',to:'q0',symbol:'b'},{from:'q3',to:'q3',symbol:'a'},{from:'q3',to:'q3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings with at least 2 'a's and at least 1 'b' over {a,b}", sol:"States track: (0a,0b), (1a,0b), (2a,0b), (0a,1b), (1a,1b), (2a,1b-final)", machine:{states:[{id:'q00',x:200,y:250,initial:true},{id:'q10',x:350,y:250},{id:'q20',x:500,y:250},{id:'q01',x:200,y:400},{id:'q11',x:350,y:400},{id:'q21',x:500,y:400,accepting:true}],transitions:[{from:'q00',to:'q10',symbol:'a'},{from:'q00',to:'q01',symbol:'b'},{from:'q10',to:'q20',symbol:'a'},{from:'q10',to:'q11',symbol:'b'},{from:'q20',to:'q20',symbol:'a'},{from:'q20',to:'q21',symbol:'b'},{from:'q01',to:'q11',symbol:'a'},{from:'q01',to:'q01',symbol:'b'},{from:'q11',to:'q21',symbol:'a'},{from:'q11',to:'q11',symbol:'b'},{from:'q21',to:'q21',symbol:'a'},{from:'q21',to:'q21',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings where every 'a' is followed by 'b' over {a,b}", sol:"States: q0(init,final), q1, q2(dead). q1 expects 'b' after 'a'", machine:{states:[{id:'q0',x:300,y:300,initial:true,accepting:true},{id:'q1',x:500,y:300},{id:'q2',x:400,y:450}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q0',symbol:'b'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings with #a - #b = 2 (mod 3) over {a,b}", sol:"Track (count_a - count_b) mod 3. States represent 0,1,2. State 2 is final", machine:{states:[{id:'q0',x:350,y:250,initial:true},{id:'q1',x:250,y:400},{id:'q2',x:450,y:400,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q2',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q0',symbol:'b'},{from:'q2',to:'q0',symbol:'a'},{from:'q2',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings beginning with 'ab' and ending with 'ba' over {a,b}", sol:"Must start 'ab' then allow anything, but track last 2 to ensure 'ba' at end", machine:{states:[{id:'q0',x:150,y:300,initial:true},{id:'q1',x:300,y:300},{id:'q2',x:450,y:300},{id:'q3',x:600,y:300,accepting:true},{id:'qd',x:375,y:450}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'qd',symbol:'b'},{from:'q1',to:'qd',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q3',symbol:'b'},{from:'q3',to:'q2',symbol:'a'},{from:'q3',to:'q3',symbol:'b'},{from:'qd',to:'qd',symbol:'a'},{from:'qd',to:'qd',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for binary strings divisible by 5", sol:"States q0-q4 represent remainder 0-4. q0 is initial and final. Each bit shifts and adds 0 or 1", machine:{states:[{id:'q0',x:350,y:150,initial:true,accepting:true},{id:'q1',x:200,y:300},{id:'q2',x:500,y:300},{id:'q3',x:250,y:450},{id:'q4',x:450,y:450}],transitions:[{from:'q0',to:'q0',symbol:'0'},{from:'q0',to:'q1',symbol:'1'},{from:'q1',to:'q2',symbol:'0'},{from:'q1',to:'q3',symbol:'1'},{from:'q2',to:'q4',symbol:'0'},{from:'q2',to:'q0',symbol:'1'},{from:'q3',to:'q1',symbol:'0'},{from:'q3',to:'q2',symbol:'1'},{from:'q4',to:'q3',symbol:'0'},{from:'q4',to:'q4',symbol:'1'}],alphabet:['0','1']}}
    ],
    easy: [
      {q:"Design a DFA that accepts all strings over {a,b}", sol:"Single state that is both initial and final, self-loops on a and b", machine:{states:[{id:'q0',x:350,y:300,initial:true,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA that accepts no strings over {a,b}", sol:"Single initial state (not final) with self-loops", machine:{states:[{id:'q0',x:350,y:300,initial:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings containing at least one 'a' over {a,b}", sol:"q0(init) no 'a' seen, q1(final) at least one 'a' seen", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings with length at least 1 over {a,b}", sol:"q0(init), q1(final). Any symbol moves to final state", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings ending with 'a' or 'b' over {a,b}", sol:"Any non-empty string ends with a or b. q0(init), q1(final for 'a'), q2(final for 'b')", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:450,y:250,accepting:true},{id:'q2',x:450,y:350,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q2',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q1',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings of length exactly 2 over {a,b}", sol:"q0(init)->q1->q2(final)->qd(dead)", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300,accepting:true},{id:'qd',x:350,y:450}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'qd',symbol:'a'},{from:'q2',to:'qd',symbol:'b'},{from:'qd',to:'qd',symbol:'a'},{from:'qd',to:'qd',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings not containing 'a' over {a,b}", sol:"q0(init,final) stays on 'b', goes to dead on 'a'", machine:{states:[{id:'q0',x:300,y:300,initial:true,accepting:true},{id:'qd',x:500,y:300}],transitions:[{from:'q0',to:'qd',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'qd',to:'qd',symbol:'a'},{from:'qd',to:'qd',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings starting with 'a' over {a,b}", sol:"q0(init), on 'a' go to q1(final) with self-loops", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:450,y:300,accepting:true},{id:'qd',x:350,y:450}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'qd',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'},{from:'qd',to:'qd',symbol:'a'},{from:'qd',to:'qd',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA that accepts empty string only over {a,b}", sol:"q0(init,final), any symbol goes to dead state", machine:{states:[{id:'q0',x:300,y:300,initial:true,accepting:true},{id:'qd',x:500,y:300}],transitions:[{from:'q0',to:'qd',symbol:'a'},{from:'q0',to:'qd',symbol:'b'},{from:'qd',to:'qd',symbol:'a'},{from:'qd',to:'qd',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design a DFA for strings with even length over {a,b}", sol:"q0(init,final) and q1. Any symbol alternates states", machine:{states:[{id:'q0',x:300,y:300,initial:true,accepting:true},{id:'q1',x:500,y:300}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q0',symbol:'a'},{from:'q1',to:'q0',symbol:'b'}],alphabet:['a','b']}}
    ]
  },
  NFA: {
    basic: [
      {q:"Design an NFA that accepts strings ending with 'ab' over {a,b}", sol:"q0(init,loops on a,b), on 'a' also goto q1, from q1 on 'b' goto q2(final)", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings containing 'aa' over {a,b}", sol:"q0(init,loops all), guess 'aa' by nondeterministic branch", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings with 'a' at 3rd position from end over {a,b}", sol:"Loop on all, guess 3rd-last 'a', then any 2 symbols", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300},{id:'q3',x:650,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q3',symbol:'a'},{from:'q2',to:'q3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA that accepts strings ending with 'ba' over {a,b}", sol:"Loop on all in q0(init), nondeterministically goto q1 on 'b', q1->q2(final) on 'a'", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q2',symbol:'a'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings with 'b' at 2nd position from end over {a,b}", sol:"Loop all, guess 2nd-last 'b', then any symbol", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA accepting strings starting or ending with 'a' over {a,b}", sol:"Two paths: start-a branch and end-a branch, combine with NFA union", machine:{states:[{id:'q0',x:250,y:250,initial:true},{id:'q1',x:450,y:250,accepting:true},{id:'q2',x:450,y:350,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'},{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q2',symbol:'a'},{from:'q2',to:'q0',symbol:'a'},{from:'q2',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings containing 'aba' or 'bab' over {a,b}", sol:"Two parallel NFA branches for each pattern", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:250},{id:'q2',x:500,y:250},{id:'q3',x:650,y:250,accepting:true},{id:'q4',x:350,y:350},{id:'q5',x:500,y:350},{id:'q6',x:650,y:350,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q3',symbol:'a'},{from:'q3',to:'q3',symbol:'a'},{from:'q3',to:'q3',symbol:'b'},{from:'q0',to:'q4',symbol:'b'},{from:'q4',to:'q5',symbol:'a'},{from:'q5',to:'q6',symbol:'b'},{from:'q6',to:'q6',symbol:'a'},{from:'q6',to:'q6',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings of length 2 or 3 over {a,b}", sol:"Parallel paths: 2-length and 3-length", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:250},{id:'q2',x:500,y:250,accepting:true},{id:'q3',x:350,y:350},{id:'q4',x:500,y:350},{id:'q5',x:650,y:350,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q0',to:'q3',symbol:'a'},{from:'q0',to:'q3',symbol:'b'},{from:'q3',to:'q4',symbol:'a'},{from:'q3',to:'q4',symbol:'b'},{from:'q4',to:'q5',symbol:'a'},{from:'q4',to:'q5',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA accepting strings with at least one 'a' over {a,b}", sol:"q0(init) loops on b, on 'a' goto q1(final) which loops on all", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings containing 'aa' or 'bb' over {a,b}", sol:"Two branches detecting 'aa' and 'bb' patterns", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:250},{id:'q2',x:550,y:250,accepting:true},{id:'q3',x:400,y:350},{id:'q4',x:550,y:350,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'},{from:'q0',to:'q3',symbol:'b'},{from:'q3',to:'q4',symbol:'b'},{from:'q4',to:'q4',symbol:'a'},{from:'q4',to:'q4',symbol:'b'}],alphabet:['a','b']}}
    ],
    medium: [
      {q:"Design an NFA for strings where 3rd symbol from end is 'a' over {a,b}", sol:"Loop all, guess position, then exactly 2 more symbols", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300},{id:'q3',x:650,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q3',symbol:'a'},{from:'q2',to:'q3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for L = {w | w contains 'aba' and has even length} over {a,b}", sol:"Combine pattern detection with parity tracking nondeterministically", machine:{states:[{id:'q0',x:200,y:250,initial:true},{id:'q1',x:350,y:250},{id:'q2',x:500,y:250},{id:'q3',x:650,y:250},{id:'qe',x:425,y:400,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q3',symbol:'a'},{from:'q3',to:'qe',symbol:'a'},{from:'q3',to:'qe',symbol:'b'},{from:'qe',to:'q3',symbol:'a'},{from:'qe',to:'q3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings not containing 'aa' over {a,b}", sol:"Track previous symbol: q0(init,final), q1(saw 'a'), reject 'aa'", machine:{states:[{id:'q0',x:300,y:300,initial:true,accepting:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for (a+b)*abb over {a,b}", sol:"Loop on a,b, nondeterministically start 'abb' sequence", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300},{id:'q3',x:650,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings with #a ≤ 2 over {a,b}", sol:"q0->q1->q2 on 'a', all loop on 'b', q0,q1,q2 are final", machine:{states:[{id:'q0',x:250,y:300,initial:true,accepting:true},{id:'q1',x:400,y:300,accepting:true},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q1',symbol:'b'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings where every 'a' is immediately followed by 'bb' over {a,b}", sol:"Loop on 'b', on 'a' must see 'bb' before returning", machine:{states:[{id:'q0',x:250,y:300,initial:true,accepting:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300}],transitions:[{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA accepting strings that start with 'ab' or end with 'ba' over {a,b}", sol:"Two paths: one for start pattern, one for end pattern", machine:{states:[{id:'q0',x:200,y:250,initial:true},{id:'q1',x:350,y:250},{id:'q2',x:500,y:250,accepting:true},{id:'q3',x:350,y:350},{id:'q4',x:500,y:350,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'},{from:'q0',to:'q3',symbol:'a'},{from:'q0',to:'q3',symbol:'b'},{from:'q3',to:'q3',symbol:'a'},{from:'q3',to:'q3',symbol:'b'},{from:'q3',to:'q4',symbol:'b'},{from:'q4',to:'q3',symbol:'a'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings containing 'aaa' or 'bbb' over {a,b}", sol:"Two branches for triple-a and triple-b patterns", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'qa1',x:350,y:250},{id:'qa2',x:500,y:250},{id:'qa3',x:650,y:250,accepting:true},{id:'qb1',x:350,y:350},{id:'qb2',x:500,y:350},{id:'qb3',x:650,y:350,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'qa1',symbol:'a'},{from:'qa1',to:'qa2',symbol:'a'},{from:'qa2',to:'qa3',symbol:'a'},{from:'qa3',to:'qa3',symbol:'a'},{from:'qa3',to:'qa3',symbol:'b'},{from:'q0',to:'qb1',symbol:'b'},{from:'qb1',to:'qb2',symbol:'b'},{from:'qb2',to:'qb3',symbol:'b'},{from:'qb3',to:'qb3',symbol:'a'},{from:'qb3',to:'qb3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings with substring 'abab' over {a,b}", sol:"Loop all, nondeterministically match 'abab' pattern", machine:{states:[{id:'q0',x:150,y:300,initial:true},{id:'q1',x:300,y:300},{id:'q2',x:450,y:300},{id:'q3',x:600,y:300},{id:'q4',x:750,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q3',symbol:'a'},{from:'q3',to:'q4',symbol:'b'},{from:'q4',to:'q4',symbol:'a'},{from:'q4',to:'q4',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings over {a,b} of length ≡ 1 (mod 3)", sol:"Count symbols mod 3, accept at state 1", machine:{states:[{id:'q0',x:350,y:250,initial:true},{id:'q1',x:250,y:400,accepting:true},{id:'q2',x:450,y:400}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q0',symbol:'a'},{from:'q2',to:'q0',symbol:'b'}],alphabet:['a','b']}}
    ],
    easy: [
      {q:"Design an NFA accepting all strings over {a,b}", sol:"Single state q0(init,final) with self-loops on a,b", machine:{states:[{id:'q0',x:350,y:300,initial:true,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings ending with 'a' over {a,b}", sol:"Loop all, nondeterministically guess last 'a'", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings containing 'a' over {a,b}", sol:"Loop all until 'a', then trap in final", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings starting with 'b' over {a,b}", sol:"On first 'b' goto final, loop there", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA accepting empty string or strings with one 'a' over {a,b}", sol:"q0(init,final), optional 'a' to q1(final), loop 'b'", machine:{states:[{id:'q0',x:300,y:300,initial:true,accepting:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings of length ≤ 2 over {a,b}", sol:"q0(init,final)->q1(final)->q2(final)", machine:{states:[{id:'q0',x:250,y:300,initial:true,accepting:true},{id:'q1',x:400,y:300,accepting:true},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings containing only 'a's over {a,b}", sol:"q0(init,final) self-loop only on 'a'", machine:{states:[{id:'q0',x:350,y:300,initial:true,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'}],alphabet:['a','b']}},
      {q:"Design an NFA accepting strings ending with 'aa' or 'bb' over {a,b}", sol:"Two branches for 'aa' and 'bb' endings", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'qa1',x:400,y:250},{id:'qa2',x:550,y:250,accepting:true},{id:'qb1',x:400,y:350},{id:'qb2',x:550,y:350,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'qa1',symbol:'a'},{from:'qa1',to:'qa2',symbol:'a'},{from:'q0',to:'qb1',symbol:'b'},{from:'qb1',to:'qb2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings with at least 2 'a's over {a,b}", sol:"Count 'a's: q0->q1->q2(final), loop 'b' everywhere", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'},{from:'q1',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design an NFA for strings over {a,b} with odd length", sol:"Alternating states: q0(init)->q1(final), toggle on any symbol", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q0',symbol:'a'},{from:'q1',to:'q0',symbol:'b'}],alphabet:['a','b']}}
    ]
  },
  ENFA: {
    basic: [
      {q:"Design ε-NFA for (a+b)* over {a,b}", sol:"Single state with ε-loop and a,b self-loops", machine:{states:[{id:'q0',x:350,y:300,initial:true,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q0',symbol:'ε'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for a*b* over {a,b}", sol:"q0(init,final) -a-> q0, q0-ε->q1(final), q1-b->q1", machine:{states:[{id:'q0',x:300,y:300,initial:true,accepting:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for a + b over {a,b}", sol:"q0(init) -ε-> q1 -a-> q2(final), q0 -ε-> q3 -b-> q4(final)", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:250},{id:'q2',x:550,y:250,accepting:true},{id:'q3',x:400,y:350},{id:'q4',x:550,y:350,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q2',symbol:'a'},{from:'q0',to:'q3',symbol:'ε'},{from:'q3',to:'q4',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for ab + ba over {a,b}", sol:"Two parallel paths with ε from start", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:250},{id:'q2',x:500,y:250,accepting:true},{id:'q3',x:350,y:350},{id:'q4',x:500,y:350,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'},{from:'q0',to:'q3',symbol:'ε'},{from:'q3',to:'q4',symbol:'b'},{from:'q4',to:'q4',symbol:'a'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for strings ending with 'ab' over {a,b}", sol:"Loop all in q0, ε to pattern matcher q1-a->q2-b->q3(final)", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300},{id:'q3',x:650,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q2',symbol:'a'},{from:'q2',to:'q3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for (a*b*)* over {a,b}", sol:"Nested ε-loops for Kleene star composition", machine:{states:[{id:'q0',x:250,y:300,initial:true,accepting:true},{id:'q1',x:450,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q1',symbol:'b'},{from:'q1',to:'q0',symbol:'ε'}],alphabet:['a','b']}},
      {q:"Design ε-NFA accepting empty string or 'a' over {a}", sol:"q0(init,final), q0-ε->q1-a->q2(final)", machine:{states:[{id:'q0',x:250,y:300,initial:true,accepting:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q2',symbol:'a'}],alphabet:['a']}},
      {q:"Design ε-NFA for a(b+c) over {a,b,c}", sol:"q0-a->q1-ε->q2-b->q3(final), q1-ε->q4-c->q5(final)", machine:{states:[{id:'q0',x:150,y:300,initial:true},{id:'q1',x:300,y:300},{id:'q2',x:450,y:250},{id:'q3',x:600,y:250,accepting:true},{id:'q4',x:450,y:350},{id:'q5',x:600,y:350,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'ε'},{from:'q2',to:'q3',symbol:'b'},{from:'q1',to:'q4',symbol:'ε'},{from:'q4',to:'q5',symbol:'c'}],alphabet:['a','b','c']}},
      {q:"Design ε-NFA for strings with optional prefix 'a' over {a,b}", sol:"q0(init)-ε->q1(final), q0-a->q1, q1 loops on b", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:450,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'ε'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for strings containing 'a' over {a,b}", sol:"q0(init) loops on b, -a-> q1(final), q1 loops all, also ε-loop", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'},{from:'q1',to:'q1',symbol:'ε'}],alphabet:['a','b']}}
    ],
    medium: [
      {q:"Design ε-NFA for (ab)* over {a,b}", sol:"Loop with ab sequence using ε back to start", machine:{states:[{id:'q0',x:250,y:300,initial:true,accepting:true},{id:'q1',x:450,y:300}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for a*+b* over {a,b}", sol:"ε-branch to two loops: one for a*, one for b*", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:450,y:250,accepting:true},{id:'q2',x:450,y:350,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q1',symbol:'a'},{from:'q0',to:'q2',symbol:'ε'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for strings with pattern 'aa' anywhere over {a,b}", sol:"Loop all, ε to aa pattern detector", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300},{id:'q3',x:650,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q2',symbol:'a'},{from:'q2',to:'q3',symbol:'a'},{from:'q3',to:'q3',symbol:'a'},{from:'q3',to:'q3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for (a+b)*abb over {a,b}", sol:"Loop on all, ε to abb sequence detector", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300},{id:'q3',x:650,y:300},{id:'q4',x:800,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q2',symbol:'a'},{from:'q2',to:'q3',symbol:'b'},{from:'q3',to:'q4',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for strings of form a^n b^n where n≥1 using ε", sol:"Push/match using states: a's then ε to b's (simplified)", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'ε'},{from:'q2',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for strings with even a's or even b's over {a,b}", sol:"Two parallel ε-branches tracking parity", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'qa0',x:400,y:250,accepting:true},{id:'qa1',x:550,y:250},{id:'qb0',x:400,y:350,accepting:true},{id:'qb1',x:550,y:350}],transitions:[{from:'q0',to:'qa0',symbol:'ε'},{from:'qa0',to:'qa1',symbol:'a'},{from:'qa1',to:'qa0',symbol:'a'},{from:'qa0',to:'qa0',symbol:'b'},{from:'qa1',to:'qa1',symbol:'b'},{from:'q0',to:'qb0',symbol:'ε'},{from:'qb0',to:'qb1',symbol:'b'},{from:'qb1',to:'qb0',symbol:'b'},{from:'qb0',to:'qb0',symbol:'a'},{from:'qb1',to:'qb1',symbol:'a'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for (a*ba*)* over {a,b}", sol:"Kleene star of pattern: a* b a* with ε transitions", machine:{states:[{id:'q0',x:200,y:300,initial:true,accepting:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300},{id:'q3',x:650,y:300}],transitions:[{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q0',symbol:'ε'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for strings starting with 'a' and ending with 'b' over {a,b}", sol:"a then anything then b using ε", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:300},{id:'q2',x:500,y:300},{id:'q3',x:650,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'ε'},{from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'},{from:'q2',to:'q3',symbol:'ε'},{from:'q3',to:'q3',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for (aa+bb)* over {a,b}", sol:"Loop structure with ε for aa or bb patterns", machine:{states:[{id:'q0',x:250,y:300,initial:true,accepting:true},{id:'qa1',x:400,y:250},{id:'qb1',x:400,y:350}],transitions:[{from:'q0',to:'qa1',symbol:'a'},{from:'qa1',to:'q0',symbol:'a'},{from:'q0',to:'qb1',symbol:'b'},{from:'qb1',to:'q0',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for union of (ab)* and (ba)* over {a,b}", sol:"ε-branch to two separate Kleene patterns", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:400,y:250,accepting:true},{id:'q2',x:550,y:250},{id:'q3',x:400,y:350,accepting:true},{id:'q4',x:550,y:350}],transitions:[{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q2',symbol:'a'},{from:'q2',to:'q1',symbol:'b'},{from:'q0',to:'q3',symbol:'ε'},{from:'q3',to:'q4',symbol:'b'},{from:'q4',to:'q3',symbol:'a'}],alphabet:['a','b']}}
    ],
    easy: [
      {q:"Design ε-NFA accepting only empty string over {a,b}", sol:"Single state q0(init,final)", machine:{states:[{id:'q0',x:350,y:300,initial:true,accepting:true}],transitions:[],alphabet:['a','b']}},
      {q:"Design ε-NFA for 'a' over {a}", sol:"q0(init) -a-> q1(final)", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'}],alphabet:['a']}},
      {q:"Design ε-NFA for strings of length ≤ 1 over {a,b}", sol:"q0(init,final) with ε or one symbol to q1(final)", machine:{states:[{id:'q0',x:300,y:300,initial:true,accepting:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for 'a' or 'b' over {a,b}", sol:"q0(init) -ε-> q1 -a-> q2(final), q0 -ε-> q3 -b-> q4(final)", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'q1',x:350,y:250},{id:'q2',x:500,y:250,accepting:true},{id:'q3',x:350,y:350},{id:'q4',x:500,y:350,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q2',symbol:'a'},{from:'q0',to:'q3',symbol:'ε'},{from:'q3',to:'q4',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA accepting 'aa' or 'bb' over {a,b}", sol:"ε-branch to two 2-symbol sequences", machine:{states:[{id:'q0',x:200,y:300,initial:true},{id:'qa1',x:350,y:250},{id:'qa2',x:500,y:250,accepting:true},{id:'qb1',x:350,y:350},{id:'qb2',x:500,y:350,accepting:true}],transitions:[{from:'q0',to:'qa1',symbol:'ε'},{from:'qa1',to:'qa2',symbol:'a'},{from:'qa2',to:'qa2',symbol:'a'},{from:'q0',to:'qb1',symbol:'ε'},{from:'qb1',to:'qb2',symbol:'b'},{from:'qb2',to:'qb2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for a* over {a}", sol:"q0(init,final) with a self-loop and ε self-loop", machine:{states:[{id:'q0',x:350,y:300,initial:true,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'ε'}],alphabet:['a']}},
      {q:"Design ε-NFA for strings ending with 'a' over {a,b}", sol:"Loop all, ε to single-a final", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:450,y:300,accepting:true}],transitions:[{from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},{from:'q0',to:'q1',symbol:'ε'},{from:'q1',to:'q1',symbol:'a'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for 'ab' over {a,b}", sol:"q0(init) -a-> q1 -b-> q2(final)", machine:{states:[{id:'q0',x:250,y:300,initial:true},{id:'q1',x:400,y:300},{id:'q2',x:550,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for strings containing at least one symbol over {a,b}", sol:"q0(init) any symbol to q1(final) which loops", machine:{states:[{id:'q0',x:300,y:300,initial:true},{id:'q1',x:500,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},{from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q1',symbol:'b'},{from:'q1',to:'q1',symbol:'ε'}],alphabet:['a','b']}},
      {q:"Design ε-NFA for (a+ε) over {a}", sol:"q0(init,final), optional 'a' via ε", machine:{states:[{id:'q0',x:250,y:300,initial:true,accepting:true},{id:'q1',x:450,y:300,accepting:true}],transitions:[{from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'ε'}],alphabet:['a']}}
    ]
  }
};

document.getElementById('splashTitle').addEventListener('click', () => {
  document.getElementById('splashScreen').style.display = 'none';
  document.getElementById('mainApp').style.display = 'block';
});

setTimeout(() => {
  document.getElementById('splashScreen').style.display = 'none';
  document.getElementById('mainApp').style.display = 'block';
}, 2000);

MODE_SELECT.addEventListener('change', () => {
  MACHINE.type = MODE_SELECT.value;
  document.getElementById('modeLabel').textContent = MACHINE.type;
  renderAll();
  layoutStatesLine(MACHINE.states);
});

function enforceInitialStateRule() {
  const initials = MACHINE.states.filter(s => s.initial);
  if (MACHINE.type === 'DFA') {
    if (initials.length === 0 && MACHINE.states.length > 0) {
      MACHINE.states[0].initial = true;
    } else if (initials.length > 1) {
      MACHINE.states.forEach((s, i) => {
        if (i > 0) s.initial = false;
      });
    }
  } else {
    if (initials.length === 0 && MACHINE.states.length > 0) {
      MACHINE.states[0].initial = true;
    }
  }
}

function renderAll() {
  const statesG = svg.querySelector('#states');
  const edgesG = svg.querySelector('#edges');
  statesG.innerHTML = '';
  edgesG.innerHTML = '';
  
  MACHINE.transitions.forEach((t, i) => {
    const from = MACHINE.states.find(s => s.id === t.from);
    const to = MACHINE.states.find(s => s.id === t.to);
    if (!from || !to) return;
    
    const isSelf = (t.from === t.to);
    let pathD, labelX, labelY;
    
    if (isSelf) {
      const loopR = 35;
      const cx = from.x;
      const cy = from.y - 40;
      pathD = `M ${from.x},${from.y - 36} 
               A ${loopR},${loopR} 0 1,1 ${from.x + 1},${from.y - 36}`;
      labelX = cx;
      labelY = cy - loopR - 8;
    } else {
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const ux = dx / dist;
      const uy = dy / dist;
      
      const startX = from.x + ux * 36;
      const startY = from.y + uy * 36;
      const endX = to.x - ux * 40;
      const endY = to.y - uy * 40;
      
      const curvature = 0.3;
      const mid = {
        x: (from.x + to.x) / 2 + curvature * (-dy),
        y: (from.y + to.y) / 2 + curvature * dx
      };
      
      if (t.from === t.to) {
      // Self-loop arc (JFLAP-style) above the state
      const loopRadius = 50;
      const startX = from.x;
      const startY = from.y - 36; // top of circle radius
      const endX = from.x + 1; // tiny offset so arrow closes nicely
      const endY = from.y - 36;
      const controlX = from.x;
      const controlY = from.y - 36 - loopRadius;
      pathD = `M ${startX},${startY} Q ${controlX},${controlY} ${endX},${endY}`;
      labelX = controlX;
      labelY = controlY - 10; // place label slightly above loop peak
    } else {
      pathD = `M ${startX},${startY} Q ${mid.x},${mid.y} ${endX},${endY}`;
      const t2 = 0.6;
      labelX = (1 - t2) * (1 - t2) * startX + 2 * (1 - t2) * t2 * mid.x + t2 * t2 * endX;
      labelY = (1 - t2) * (1 - t2) * startY + 2 * (1 - t2) * t2 * mid.y + t2 * t2 * endY;
      const perpX = -uy;
      const perpY = ux;
      const offset = 15;
      labelX += perpX * offset;
      labelY += perpY * offset;
    }      
      const t2 = 0.6;
      labelX = (1 - t2) * (1 - t2) * startX + 2 * (1 - t2) * t2 * mid.x + t2 * t2 * endX;
      labelY = (1 - t2) * (1 - t2) * startY + 2 * (1 - t2) * t2 * mid.y + t2 * t2 * endY;
      
      const perpX = -uy;
      const perpY = ux;
      const offset = 15;
      labelX += perpX * offset;
      labelY += perpY * offset;
    }
    
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathD);
    path.setAttribute('class', 'transition-path');
    path.setAttribute('data-from', t.from);
    path.setAttribute('data-to', t.to);
    path.setAttribute('data-index', i);
    path.style.cursor = 'pointer';
    
    const symLabel = (t.symbol === '' || t.symbol === undefined) ? 'ε' : t.symbol;

    // keep the path click handler as before
    path.addEventListener('click', (e) => {
      e.stopPropagation();
      if (CURRENT_MODE === 'delete') {
        deleteTransition(i);
      }
    });

    // append the path first, then add a stacked label (newest on top) that is tied to this (from,to) pair
    edgesG.appendChild(path);
    addTransitionLabel(edgesG, labelX, labelY, symLabel, t.from, t.to);
  });
  
  MACHINE.states.forEach(st => {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('data-id', st.id);
    g.setAttribute('transform', `translate(${st.x},${st.y})`);
    
    const circ = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circ.setAttribute('r', '36');
    circ.setAttribute('class', 'state-circle');
    if (st.accepting) {
      circ.classList.add('anim-final-inner');
    if (st.initial) { circ.classList.add('initial-pulse'); }
    }
    
    if (st.accepting) {
      const ring = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      ring.setAttribute('r', '42');
      ring.setAttribute('class', 'final-ring anim-final-ring');
      g.appendChild(ring);
    }
    
    g.appendChild(circ);
    
    if (st.initial) {
      const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      arrowPath.setAttribute('d', 'M -80,0 L -40,0'); // straight line instead of bent
      arrowPath.setAttribute('class', 'initial-arrow anim-initial-arrow');
      arrowPath.setAttribute('fill', 'none');
      g.appendChild(arrowPath);
    }
    
    const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    txt.setAttribute('class', 'state-label');
    txt.textContent = st.id;
    g.appendChild(txt);
    
    g.style.cursor = 'pointer';
    
    let isDragging = false;
    let startX, startY;
    
    g.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      e.preventDefault();
      
      if (CURRENT_MODE === 'move') {
        isDragging = true;
        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
        startX = svgP.x - st.x;
        startY = svgP.y - st.y;
      } else if (CURRENT_MODE === 'delete') {
        deleteState(st.id);
      } else if (CURRENT_MODE === 'transition') {
        if (!TRANS_FROM) {
          TRANS_FROM = st.id;
          SELECTED_STATE = st.id;
          circ.classList.add('state-selected');
        } else {
          showTransModal(TRANS_FROM, st.id);
          document.querySelectorAll('.state-circle').forEach(c => c.classList.remove('state-selected'));
          TRANS_FROM = null;
          SELECTED_STATE = null;
        }
      } else if (CURRENT_MODE === 'rename') {
        renameState(st.id);
      } else if (CURRENT_MODE === 'stateprops') {
        openPropsModal(st.id);
      }
    });
    
    g.addEventListener('mousemove', (e) => {
      if (isDragging && CURRENT_MODE === 'move') {
        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
        st.x = svgP.x - startX;
        st.y = svgP.y - startY;
        renderAll();
      }
    });
    
    g.addEventListener('mouseup', () => {
      isDragging = false;
    });
    
    statesG.appendChild(g);
  });
  
  document.getElementById('canvasHint').style.display = MACHINE.states.length ? 'none' : 'block';
}

function layoutStatesLine(states) {
  if (!states || states.length === 0) return;
  const startX = 200;
  const spacing = 150;
  const baseY = 300;
  states.forEach((s, i) => {
    s.x = startX + i * spacing;
    s.y = baseY + (i % 2 === 0 ? 0 : 50);
  });
  renderAll();
}

const tools = document.querySelectorAll('.toolbar-icon[data-mode]');
tools.forEach(tool => {
  tool.addEventListener('click', () => {
    tools.forEach(t => t.classList.remove('active'));
    tool.classList.add('active');
    CURRENT_MODE = tool.dataset.mode;
    TRANS_FROM = null;
    SELECTED_STATE = null;
    document.querySelectorAll('.state-circle').forEach(c => c.classList.remove('state-selected'));
  });
});

document.querySelector('[data-mode="addclick"]').classList.add('active');

svg.addEventListener('click', (e) => {
  if (CURRENT_MODE === 'addclick') {
    const pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
    addState(svgP.x, svgP.y);
  }
});

function addState(x, y) {
  const id = 'q' + MACHINE.states.length;
  const isFirst = MACHINE.states.length === 0;
  pushUndo();
  MACHINE.states.push({
    id: id,
    x: x,
    y: y,
    initial: isFirst,
    accepting: false
  });
  renderAll();
  
  const stateG = document.querySelector(`[data-id="${id}"]`);
  if (stateG) {
    const circle = stateG.querySelector('circle');
    if (circle) {
      circle.classList.add('state-drawing');
      setTimeout(() => circle.classList.remove('state-drawing'), 600);
    }
  }
}

function renameState(oldId) {
  const newId = prompt('Enter new state name:', oldId);
  if (!newId || newId === oldId) return;
  if (MACHINE.states.find(s => s.id === newId)) {
    alert('State name already exists');
    return;
  }
  pushUndo();
  const st = MACHINE.states.find(s => s.id === oldId);
  if (st) st.id = newId;
  MACHINE.transitions.forEach(t => {
    if (t.from === oldId) t.from = newId;
    if (t.to === oldId) t.to = newId;
  });
  renderAll();
}

function openPropsModal(stateId) {
  const modal = document.getElementById('statePropsModal');
  modal.dataset.stateId = stateId;
  const st = MACHINE.states.find(s => s.id === stateId);
  if (!st) return;
  document.getElementById('propInitial').checked = st.initial;
  document.getElementById('propFinal').checked = st.accepting;
  modal.style.display = 'flex';
}

function showTransModal(from, to) {
  const modal = document.getElementById('transitionModal');
  document.getElementById('transFrom').value = from;
  document.getElementById('transTo').value = to;
  document.getElementById('transSymbol').value = '';
  modal.style.display = 'flex';
}

function hideTransModal() {
  document.getElementById('transitionModal').style.display = 'none';
}

document.getElementById('transCancel').addEventListener('click', hideTransModal);

document.getElementById('transSave').addEventListener('click', () => {
  const from = document.getElementById('transFrom').value.trim();
  const to = document.getElementById('transTo').value.trim();
  const symRaw = document.getElementById('transSymbol').value.trim();
  let sym = symRaw;
  
  if (symRaw === '') {
    if (MACHINE.type === 'DFA') {
      hideTransModal();
      return;
    } else {
      sym = 'ε';
    }
  }
  
  if (!from || !to) {
    alert('Fill both from and to states');
    return;
  }
  
  if (MACHINE.type === 'DFA') {
    const conflict = MACHINE.transitions.find(t => t.from === from && t.symbol === sym && t.to !== to);
    if (conflict) {
      alert('DFA: transition for this symbol from state already exists');
      return;
    }
  }
  
  pushUndo();
  MACHINE.transitions.push({ from, to, symbol: sym });
  updateAlphabet();
  renderAll();
  layoutStatesLine(MACHINE.states);
  hideTransModal();
  
  setTimeout(() => {
    const pathEl = document.querySelector(`.transition-path[data-from="${from}"][data-to="${to}"]`);
    if (pathEl) {
      pathEl.classList.add('transition-drawing');
      setTimeout(() => pathEl.classList.remove('transition-drawing'), 800);
    }
  }, 50);
});

function deleteTransition(i) {
  pushUndo();
  MACHINE.transitions.splice(i, 1);
  renderAll();
  layoutStatesLine(MACHINE.states);
}

function deleteState(id) {
  pushUndo();
  MACHINE.states = MACHINE.states.filter(s => s.id !== id);
  MACHINE.transitions = MACHINE.transitions.filter(t => t.from !== id && t.to !== id);
  enforceInitialStateRule();
  renderAll();
  layoutStatesLine(MACHINE.states);
}

function updateAlphabet() {
  const set = new Set();
  MACHINE.transitions.forEach(t => {
    if (t.symbol && t.symbol !== 'ε') set.add(t.symbol);
  });
  MACHINE.alphabet = Array.from(set);
}

function pushUndo() {
  UNDO_STACK.push(JSON.parse(JSON.stringify(MACHINE)));
  REDO_STACK = [];
  updateUndoRedoButtons();
}

function doUndo() {
  if (UNDO_STACK.length === 0) return;
  REDO_STACK.push(JSON.parse(JSON.stringify(MACHINE)));
  MACHINE = UNDO_STACK.pop();
  renderAll();
  layoutStatesLine(MACHINE.states);
  updateUndoRedoButtons();
}

function doRedo() {
  if (REDO_STACK.length === 0) return;
  UNDO_STACK.push(JSON.parse(JSON.stringify(MACHINE)));
  MACHINE = REDO_STACK.pop();
  renderAll();
  layoutStatesLine(MACHINE.states);
  updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
  if (undoBtn) undoBtn.disabled = UNDO_STACK.length === 0;
  if (redoBtn) redoBtn.disabled = REDO_STACK.length === 0;
}

let CURRENT_PRACTICE = null;

genPracticeBtn.addEventListener('click', () => {
  const mode = MACHINE.type;
  const level = document.getElementById('practiceMode').value;
  const bank = PRACTICE_BANK[mode] && PRACTICE_BANK[mode][level];
  if (!bank || bank.length === 0) {
    practiceBox.textContent = "No questions available.";
    return;
  }
  CURRENT_PRACTICE = bank[Math.floor(Math.random() * bank.length)];
  practiceBox.innerHTML = `<strong>${mode} | ${level}</strong>
    <div style="margin-top:8px">${CURRENT_PRACTICE.q}</div>
    <div style="margin-top:8px;color:var(--muted)">Click "Show Solution" to see the answer, or "Check Answer" to validate your design.</div>`;
});

showSolBtn.addEventListener('click', async () => {
  if (!CURRENT_PRACTICE) {
    alert('No practice generated yet.');
    return;
  }
  
  practiceBox.innerHTML = `
    <strong>Problem</strong>
    <div style="margin-top:8px">${CURRENT_PRACTICE.q}</div>
    <strong style="margin-top:8px;display:block">Solution</strong>
    <div style="margin-top:8px;white-space:pre-line">${CURRENT_PRACTICE.sol}</div>`;
  
  if (CURRENT_PRACTICE.machine) {
    await animateConstruction(CURRENT_PRACTICE.machine);
  }
});

async function animateConstruction(machineData) {
  pushUndo();
  
  MACHINE.states = [];
  MACHINE.transitions = [];
  renderAll();
  
  document.getElementById('stepLog').innerHTML = '<div>🔧 Starting construction...</div>';
  
  const speed = parseInt(document.getElementById('testSpeed').value || '2000');
  const states = machineData.states || [];
  const transitions = machineData.transitions || [];
  
  for (let i = 0; i < states.length; i++) {
    const s = states[i];
    const stateData = {
      id: s.id,
      x: s.x || 150,
      y: s.y || 150,
      initial: !!s.initial,
      accepting: !!s.accepting
    };
    
    MACHINE.states.push(stateData);
    renderAll();
    
    const stateG = document.querySelector(`[data-id="${s.id}"]`);
    if (stateG) {
      const circle = stateG.querySelector('circle');
      if (circle) {
        circle.classList.add('state-drawing');
        setTimeout(() => circle.classList.remove('state-drawing'), 600);
      }
    }
    
    let stateType = '';
    if (s.initial && s.accepting) stateType = ' (initial & final)';
    else if (s.initial) stateType = ' (initial)';
    else if (s.accepting) stateType = ' (final)';
    
    const stepMsg = `Step ${i + 1}: Created state ${s.id}${stateType}`;
    addConstructionLog(stepMsg);
    
    await sleep(speed);
  }
  
  for (let i = 0; i < transitions.length; i++) {
    const t = transitions[i];
    const symbol = t.symbol || 'ε';
    
    if (MACHINE.type === 'DFA' && symbol === 'ε') continue;
    
    MACHINE.transitions.push({
      from: t.from,
      to: t.to,
      symbol: symbol
    });
    
    renderAll();
    
    const pathEl = document.querySelector(`.transition-path[data-from="${t.from}"][data-to="${t.to}"]`);
    if (pathEl) {
      pathEl.classList.add('transition-drawing');
      setTimeout(() => pathEl.classList.remove('transition-drawing'), 800);
    }
    
    const stepMsg = `Step ${states.length + i + 1}: Drew transition from ${t.from} to ${t.to} on symbol '${symbol}'`;
    addConstructionLog(stepMsg);
    
    await sleep(speed);
  }
  
  MACHINE.alphabet = machineData.alphabet || [];
  
  addConstructionLog('✅ Construction complete!');
}

function addConstructionLog(message) {
  const log = document.getElementById('stepLog');
  const div = document.createElement('div');
  div.className = 'new-log';
  div.innerHTML = `<i>▶</i> ${message}`;
  log.innerHTML = div.outerHTML + log.innerHTML;
  log.scrollTop = 0;
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

resetPractice.addEventListener('click', () => {
  CURRENT_PRACTICE = null;
  practiceBox.textContent = 'No practice generated yet.';
});

checkAnswerBtn.addEventListener('click', () => {
  if (!CURRENT_PRACTICE) {
    alert('No practice generated yet.');
    return;
  }
  
  const validation = validateAutomaton();
  
  if (validation.includes('invalid')) {
    practiceBox.innerHTML = `<div style="color:red;font-weight:bold">❌ Your automaton is invalid!</div>
      <div style="margin-top:8px">${validation}</div>
      <div style="margin-top:8px;color:var(--muted)">Fix the errors and try again.</div>`;
    return;
  }
  
  practiceBox.innerHTML = `<div style="color:green;font-weight:bold">✓ Your automaton is valid!</div>
    <div style="margin-top:8px">Compare your solution with the expected one using "Show Solution".</div>`;
});

let simSteps = [], simIndex = 0, simTimer = null;

async function runSimulation(inputStr) {
  if (typeof inputStr !== 'string') inputStr = '' + (inputStr || '');
  simSteps = [];
  simIndex = 0;
  clearTimeout(simTimer);
  document.getElementById('stepLog').innerHTML = '';
  testOutput.textContent = '';

  const startStates = MACHINE.states.filter(s => s.initial).map(s => s.id);
  if (startStates.length === 0) {
    alert('No initial state set.');
    return;
  }
  if (MACHINE.type === 'DFA' && startStates.length > 1) {
    console.warn('Multiple initial states found in DFA mode — using the first one.');
  }

  let currentSet = (MACHINE.type === 'ENFA') ? epsilonClosure(startStates) : [...startStates];
  if (MACHINE.type === 'DFA' && currentSet.length > 1) currentSet = [currentSet[0]];

  const symbols = inputStr.split('').filter(ch => ch !== '');

  for (const sym of symbols) {
    const frame = { before: [...currentSet], symbol: sym, steps: [], after: [] };
    const next = new Set();

    if (MACHINE.type === 'DFA') {
      if (currentSet.length > 0) {
        const q = currentSet[0];
        const t = MACHINE.transitions.find(tt => tt.from === q && tt.symbol === sym);
        if (t) {
          frame.steps.push({ from: q, to: t.to, symbol: t.symbol });
          next.add(t.to);
        }
      }
    } else {
      for (const q of currentSet) {
        MACHINE.transitions.filter(t => t.from === q && t.symbol === sym).forEach(t => {
          frame.steps.push({ from: q, to: t.to, symbol: t.symbol });
          next.add(t.to);
        });
      }
    }

    const after = (MACHINE.type === 'ENFA') ? epsilonClosure([...next]) : [...next];
    frame.after = after;
    simSteps.push(frame);
    currentSet = after;
    if (currentSet.length === 0) break;
  }

  simSteps.push({ end: true, active: [...currentSet] });

  const mode = document.querySelector('input[name="simMode"]:checked')?.value || 'auto';
  if (mode === 'manual') {
    document.getElementById('manualButtons').style.display = 'flex';
    simIndex = 0;
    await showStep(0);
    simIndex = 1;
  } else {
    document.getElementById('manualButtons').style.display = 'none';
    playAuto();
  }
}

function epsilonClosure(list) {
  const out = new Set(list);
  const stack = [...list];
  while (stack.length) {
    const q = stack.pop();
    MACHINE.transitions.filter(t => t.from === q && (t.symbol === '' || t.symbol === 'ε')).forEach(t => {
      if (!out.has(t.to)) {
        out.add(t.to);
        stack.push(t.to);
      }
    });
  }
  return [...out];
}

function animateElement(el, cls, duration) {
  return new Promise(resolve => {
    if (!el) {
      resolve();
      return;
    }
    el.classList.add(cls);
    el.style.animationDuration = duration + 'ms';
    let finished = false;
    const done = () => {
      if (finished) return;
      finished = true;
      try {
        el.classList.remove(cls);
      } catch (e) {}
      el.removeEventListener('animationend', done);
      resolve();
    };
    el.addEventListener('animationend', done);
    setTimeout(() => { done(); }, duration + 120);
  });
}

async function showStep(idx) {
  if (idx < 0 || idx >= simSteps.length) return;
  simIndex = idx;
  const step = simSteps[idx];

  document.querySelectorAll('.state-circle').forEach(c => {
    c.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--accent1'));
    c.setAttribute('stroke-width', '3');
  });
  document.querySelectorAll('.transition-path').forEach(p => {
    p.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--accent1'));
    p.setAttribute('stroke-width', '2');
  });

  const log = document.getElementById('stepLog');
  if (log && idx === 0) log.innerHTML = '';

  const speed = parseInt(document.getElementById('testSpeed').value || '500');
  const animMs = Math.max(120, Math.round(speed * 0.6));

  if (step.end) {
    for (const sid of (step.active || [])) {
      const g = document.querySelector(`[data-id="${sid}"]`);
      if (g) {
        const circ = g.querySelector('circle');
        await animateElement(circ, 'state-animating', animMs);
      }
    }
    const accept = (step.active || []).some(sid => MACHINE.states.find(s => s.id === sid && s.accepting));
    testOutput.textContent = accept ? 'Accepted' : 'Rejected';
    testOutput.style.color = accept ? 'green' : 'red';
    if (log) log.innerHTML = `<div><strong style="color:${accept ? 'green' : 'red'}">${accept ? '✔ Accepted' : '✘ Rejected'}</strong></div>` + log.innerHTML;
    if (log) log.innerHTML = `<div><strong>Final active: {${(step.active || []).join(', ')}}</strong></div>` + log.innerHTML;
    return;
  }

  await Promise.all((step.before || []).map(async sid => {
    const g = document.querySelector(`[data-id="${sid}"]`);
    if (g) {
      const circ = g.querySelector('circle');
      await animateElement(circ, 'state-animating', animMs);
    }
  }));

  if (step.steps && step.steps.length) {
    for (const s of step.steps) {
      if (log) {
        log.innerHTML = `<div>In {${s.from}} on '${s.symbol}' → {${s.to}}</div>` + log.innerHTML;
        log.scrollTop = 0;
      }
      const fromG = document.querySelector(`[data-id="${s.from}"]`);
      if (fromG) {
        const circ = fromG.querySelector('circle');
        await animateElement(circ, 'state-animating', Math.max(80, Math.round(animMs * 0.5)));
      }
      const pathEl = document.querySelector(`.transition-path[data-from="${s.from}"][data-to="${s.to}"]`);
      if (pathEl) {
        await animateElement(pathEl, 'transition-animating', animMs);
      }
    }
  } else {
    if (log) log.innerHTML = `<div>No outgoing transitions from {${(step.before || []).join(', ')}} on '${step.symbol}' → ∅</div>` + log.innerHTML;
    await new Promise(r => setTimeout(r, animMs));
  }

  await Promise.all((step.after || []).map(async sid => {
    const g = document.querySelector(`[data-id="${sid}"]`);
    if (g) {
      const circ = g.querySelector('circle');
      await animateElement(circ, 'state-animating', animMs);
    }
  }));

  testOutput.textContent = `After '${step.symbol}' active: {${(step.after || []).join(', ')}}`;
}

async function playAuto() {
  const speed = parseInt(document.getElementById('testSpeed').value || '500');
  const total = simSteps.length;
  for (let i = 0; i < total; i++) {
    await showStep(i);
  }
}

document.getElementById('stepNext').addEventListener('click', async () => {
  if (simIndex < simSteps.length) {
    await showStep(simIndex);
    simIndex++;
  }
});

document.getElementById('stepPrev').addEventListener('click', async () => {
  if (simIndex > 0) {
    simIndex = Math.max(0, simIndex - 1);
    await showStep(simIndex);
  }
});

document.getElementById('stepReset').addEventListener('click', () => {
  simIndex = 0;
  simSteps = [];
  clearTimeout(simTimer);
  document.getElementById('stepLog').innerHTML = '';
  document.getElementById('testOutput').textContent = '';
  document.querySelectorAll('.state-circle').forEach(c => c.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--accent1')));
  document.querySelectorAll('.transition-path').forEach(p => p.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--accent1')));
});

runTestBtn.addEventListener('click', async () => {
  const str = testInput.value.trim();
  await runSimulation(str);
});

document.getElementById("genRandBtn").addEventListener("click", async () => {
  const alphabet = MACHINE.alphabet.length ? MACHINE.alphabet : ["a", "b"];
  const numStates = MACHINE.states.length || 1;
  const numTrans = MACHINE.transitions.length || 1;

  let length;
  if (numStates <= 2 || numTrans <= 2) {
    length = Math.floor(Math.random() * 3) + 1;
  } else {
    const bias = Math.random();
    if (bias < 0.6) {
      length = Math.floor(Math.random() * 4) + 4;
    } else {
      length = Math.floor(Math.random() * 12) + 4;
    }
  }

  let str = "";
  for (let i = 0; i < length; i++) {
    str += alphabet[Math.floor(Math.random() * alphabet.length)];
  }

  const inputEl = document.getElementById("testInput");
  inputEl.value = str;
  await runSimulation(str);
});

function setZoom(pct) {
  svg.style.transform = `scale(${pct / 100})`;
  svg.style.transformOrigin = '0 0';
  zoomSlider.value = pct;
}

zoomSlider.addEventListener('input', e => setZoom(e.target.value));
zoomInBtn.addEventListener('click', () => setZoom(Math.min(200, Number(zoomSlider.value) + 10)));
zoomOutBtn.addEventListener('click', () => setZoom(Math.max(50, Number(zoomSlider.value) - 10)));
zoomResetBtn.addEventListener('click', () => setZoom(100));

const propSave = document.getElementById('propSave');
const propCancel = document.getElementById('propCancel');

propSave.addEventListener('click', () => {
  const modal = document.getElementById('statePropsModal');
  const stateId = modal.dataset.stateId;
  const s = MACHINE.states.find(st => st.id === stateId);

  if (s) {
    if (document.getElementById('propInitial').checked) {
      if (MACHINE.type === 'DFA') {
        MACHINE.states.forEach(x => x.initial = false);
        s.initial = true;
      } else {
        s.initial = true;
      }
    } else {
      s.initial = false;
    }
    s.accepting = !!document.getElementById('propFinal').checked;
    renderAll();
    layoutStatesLine(MACHINE.states);
  }

  modal.style.display = 'none';
});

propCancel.addEventListener('click', () => {
  document.getElementById('statePropsModal').style.display = 'none';
});

renderAll();
layoutStatesLine(MACHINE.states);
setZoom(100);

window.addEventListener('load', () => {
  if (window.lucide) {
    lucide.createIcons();
  }
});

document.getElementById("saveMachineBtn").addEventListener("click", () => {
  const data = JSON.stringify({ states: MACHINE.states, transitions: MACHINE.transitions }, null, 2);
  const blob = new Blob([data], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "machine.json";
  a.click();
  URL.revokeObjectURL(url);
});

document.getElementById("loadMachineBtn").addEventListener("click", () => {
  document.getElementById("loadFileInput").click();
});

document.getElementById("loadFileInput").addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const obj = JSON.parse(ev.target.result);
      if (obj.states && obj.transitions) {
        MACHINE.states = obj.states;
        MACHINE.transitions = obj.transitions;
        renderAll();
        layoutStatesLine(MACHINE.states);
      } else {
        alert("Invalid machine file");
      }
    } catch (err) {
      alert("Error loading file: " + err.message);
    }
  };
  reader.readAsText(file);
});

function validateAutomaton() {
  const modeRaw = document.getElementById('modeSelect').value || '';
  const mode = ('' + modeRaw).toUpperCase();
  const states = MACHINE.states || [];
  const transitions = MACHINE.transitions || [];
  let valid = true;
  const initialCount = states.filter(s => s.initial).length;

  if (mode === 'DFA') {
    if (initialCount !== 1) valid = false;
    if (transitions.some(tr => (tr.symbol === 'ε' || tr.symbol === '' || tr.symbol === undefined))) valid = false;
    for (const st of states) {
      const seen = {};
      for (const t of transitions.filter(tt => tt.from === st.id)) {
        const sym = (t.symbol === undefined || t.symbol === '') ? 'ε' : t.symbol;
        if (sym === 'ε') {
          valid = false;
          break;
        }
        if (seen[sym]) {
          valid = false;
          break;
        }
        seen[sym] = true;
      }
      if (!valid) break;
    }
    return valid ? "✔ DFA valid (Q=" + states.length + ", Σ=" + MACHINE.alphabet.join(',') + ", q0=" + states.filter(s=>s.initial).map(s=>s.id).join(',') + ", F=" + states.filter(s=>s.accepting).map(s=>s.id).join(',') + ")" : "✘ DFA invalid (must have exactly 1 initial state, no ε-transitions, deterministic δ)";
  } else if (mode === 'NFA') {
    if (initialCount < 1) valid = false;
    if (transitions.some(tr => (tr.symbol === 'ε' || tr.symbol === '' || tr.symbol === undefined))) valid = false;
    return valid ? "✔ NFA valid (Q=" + states.length + ", Σ=" + MACHINE.alphabet.join(',') + ", q0={" + states.filter(s=>s.initial).map(s=>s.id).join(',') + "}, F={" + states.filter(s=>s.accepting).map(s=>s.id).join(',') + "})" : "✘ NFA invalid (needs ≥1 initial state, no ε-transitions)";
  } else if (mode === 'ENFA' || mode === 'ε-NFA' || mode === 'E-NFA') {
    if (initialCount < 1) valid = false;
    return valid ? "✔ ε-NFA valid (Q=" + states.length + ", Σ=" + MACHINE.alphabet.join(',') + ", q0={" + states.filter(s=>s.initial).map(s=>s.id).join(',') + "}, F={" + states.filter(s=>s.accepting).map(s=>s.id).join(',') + "})" : "✘ ε-NFA invalid (needs ≥1 initial state)";
  }
  return "✘ Invalid";
}

(function() {
  const attach = () => {
    const btn = document.getElementById('validateBtn');
    if (!btn) return;
    btn.removeEventListener('click', btn._validateHandler || (() => {}));
    const handler = function() {
      const msg = validateAutomaton();
      const parent = btn.parentElement || document.body;
      let old = parent.querySelector('#validationBox');
      if (old) old.remove();
      const box = document.createElement('div');
      box.id = 'validationBox';
      box.className = 'validation-box';
      box.innerHTML = (msg.indexOf('✔') >= 0) ? `<span style='color:green'>${msg}</span>` : `<span style='color:red'>${msg}</span>`;
      box.style.position = 'absolute';
      box.style.top = (btn.offsetTop + btn.offsetHeight + 6) + 'px';
      const btnRect = btn.getBoundingClientRect();
      const parentRect = parent.getBoundingClientRect();
      box.style.left = (btnRect.left - parentRect.left) + 'px';
      parent.appendChild(box);
      setTimeout(() => box.classList.add('show'), 50);
      setTimeout(() => {
        box.classList.remove('show');
        setTimeout(() => box.remove(), 350);
      }, 4000);
    };
    btn._validateHandler = handler;
    btn.addEventListener('click', handler);
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attach);
  } else {
    attach();
  }
})();
</script>

<script>
(function() {
  function inlineStyles(el) {
    try {
      const computed = getComputedStyle(el);
      const importantProps = [
        "fill", "stroke", "stroke-width",
        "font-size", "font-family", "font-weight", "text-anchor",
        "dominant-baseline"
      ];
      for (const key of importantProps) {
        const val = computed.getPropertyValue(key);
        if (val) el.style[key] = val;
      }
    } catch (e) {}
    for (const child of el.children || []) {
      inlineStyles(child);
    }
  }

  function setupExport() {
    const btn = document.getElementById("exportPngBtn");
    if (!btn) return;
    if (btn._exportBound) return;
    btn._exportBound = true;

    btn.addEventListener("click", function() {
      const svg = document.getElementById("dfaSVG");
      if (!svg) {
        alert("SVG not found");
        return;
      }

      const clone = svg.cloneNode(true);
      inlineStyles(clone);

      const vb = svg.viewBox && svg.viewBox.baseVal;
      let width = (vb && vb.width) ? Math.ceil(vb.width) : Math.ceil(svg.clientWidth || 1400);
      let height = (vb && vb.height) ? Math.ceil(vb.height) : Math.ceil(svg.clientHeight || 900);
      if (width <= 0) width = 1400;
      if (height <= 0) height = 900;

      clone.setAttribute("width", width);
      clone.setAttribute("height", height);
      if (!clone.getAttribute("xmlns")) clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");

      const svgStr = new XMLSerializer().serializeToString(clone);
      const svgBlob = new Blob([svgStr], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);
        
        ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);

        canvas.toBlob(function(blob) {
          const pngUrl = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = pngUrl;
          a.download = "automaton.png";
          a.click();
          URL.revokeObjectURL(pngUrl);
        }, "image/png");
      };
      img.src = url;
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener("DOMContentLoaded", setupExport);
  } else {
    setupExport();
  }
})();
</script>


<!-- INTEGRATED PATCH: Full feature integration (move, undo/redo, conversions, export, layout, practice expansion) -->
<script>
(function(){
  // Helpers
  const svg = document.getElementById('dfaSVG');
  const statesGroup = document.getElementById('states');
  const edgesGroup = document.getElementById('edges');
  const modeSelect = document.getElementById('modeSelect');
  const exportBtn = document.getElementById('exportPngBtn');
  const validateBtn = document.getElementById('validateBtn');
  const canvasWrapper = document.getElementById('canvasWrapper');

  // Safe-get render function
  function doRender(){
    if (typeof renderAll === 'function') return renderAll();
    if (typeof drawMachine === 'function') return drawMachine();
    if (typeof renderMachine === 'function') return renderMachine();
    // fallback: naive re-draw from MACHINE
    if (window.MACHINE && typeof window.MACHINE === 'object') {
      // attempt simple draw: clear and re-create nodes if minimal functions absent
      if (statesGroup && edgesGroup) {
        while(statesGroup.firstChild) statesGroup.removeChild(statesGroup.firstChild);
        while(edgesGroup.firstChild) edgesGroup.removeChild(edgesGroup.firstChild);
        try {
          const svgNS = "http://www.w3.org/2000/svg";
          for (const s of (window.MACHINE.states || [])) {
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('data-id', s.id);
            g.classList.add('state-node');
            const c = document.createElementNS(svgNS, 'circle');
            c.setAttribute('cx', s.x || 300);
            c.setAttribute('cy', s.y || 200);
            c.setAttribute('r', 30);
            c.setAttribute('class', 'state-circle');
            c.setAttribute('data-id', s.id);
            const t = document.createElementNS(svgNS, 'text');
            t.setAttribute('x', s.x || 300);
            t.setAttribute('y', s.y || 200);
            t.setAttribute('class', 'state-label');
            t.textContent = s.id;
            g.appendChild(c);
            g.appendChild(t);
            statesGroup.appendChild(g);
          }
          for (const tr of (window.MACHINE.transitions || [])) {
            const path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
            path.setAttribute('class','transition-path');
            const from = window.MACHINE.states.find(x=>x.id===tr.from);
            const to = window.MACHINE.states.find(x=>x.id===tr.to);
            if (from && to) {
              if (from.id === to.id) {
                const out = getLoopPathAndLabel(from.x||300, from.y||200, 30, window.MACHINE.states||[], from.id, tr.symbol);
                path.setAttribute('d', out.pathData);
                addTransitionLabel(edgesGroup, out.labelX, out.labelY, tr.symbol, tr.from, tr.to);
              } else {
                const d = `M ${from.x} ${from.y} L ${to.x} ${to.y}`;
                path.setAttribute('d', d);
                addTransitionLabel(edgesGroup, (from.x+to.x)/2, (from.y+to.y)/2, tr.symbol, tr.from, tr.to);
              }
            }
            edgesGroup.appendChild(path);
          }
        } catch(e){ console.error(e); }
      }
    }
  }

  // --- Undo/Redo stacks ---
  window.UNDO_STACK = window.UNDO_STACK || [];
  window.REDO_STACK = window.REDO_STACK || [];
  function snapshot() {
    try { return JSON.parse(JSON.stringify(window.MACHINE || {type:'DFA',states:[],transitions:[],alphabet:[]})); }
    catch(e){ return {type:'DFA',states:[],transitions:[],alphabet:[]}; }
  }
  function pushUndo() {
    window.UNDO_STACK.push(snapshot());
    if (window.UNDO_STACK.length>200) window.UNDO_STACK.shift();
    window.REDO_STACK = [];
  }
  window.undoAction = function(){
    if (!window.UNDO_STACK.length) return;
    const last = window.UNDO_STACK.pop();
    window.REDO_STACK.push(snapshot());
    window.MACHINE = last;
    clampStatesToView();
    doRender();
  };
  window.redoAction = function(){
    if (!window.REDO_STACK.length) return;
    const next = window.REDO_STACK.pop();
    window.UNDO_STACK.push(snapshot());
    window.MACHINE = next;
    clampStatesToView();
    doRender();
  };

  // Add toolbar buttons (after validate)
  function injectUndoRedoButtons(){
    const toolbar = document.querySelector('.canvas-toolbar');
    if (!toolbar) return;
    if (document.getElementById('undoBtn')) return;
    const u = document.createElement('div');
    u.id = 'undoBtn'; u.className='toolbar-icon'; u.title='Undo'; u.innerHTML = '↶';
    const r = document.createElement('div');
    r.id = 'redoBtn'; r.className='toolbar-icon'; r.title='Redo'; r.innerHTML = '↷';
    toolbar.appendChild(u);
    toolbar.appendChild(r);
    u.addEventListener('click', ()=>window.undoAction());
    r.addEventListener('click', ()=>window.redoAction());
    window.addEventListener('keydown', function(e){
      const mac = navigator.platform.toUpperCase().indexOf('MAC')>=0;
      if ((mac?e.metaKey:e.ctrlKey) && e.key.toLowerCase()==='z') { e.preventDefault(); window.undoAction(); }
      if ((mac?e.metaKey:e.ctrlKey) && (e.key.toLowerCase()==='y' || (e.shiftKey && e.key.toLowerCase()==='z'))) { e.preventDefault(); window.redoAction(); }
    });
  }

  // --- Smooth move tool (glider) ---
  function setupSmoothMoveTool(){
    if (!svg || !statesGroup) return;
    let dragging = null;
    let lastPos = {x:0,y:0};
    let raf = null;
    let currentCircle = null;
    const lerp = (a,b,t)=>a+(b-a)*t;

    function getPoint(evt){
      const pt = svg.createSVGPoint();
      if (evt.touches && evt.touches[0]) { pt.x = evt.touches[0].clientX; pt.y = evt.touches[0].clientY; }
      else { pt.x = evt.clientX; pt.y = evt.clientY; }
      const ctm = svg.getScreenCTM().inverse();
      return pt.matrixTransform(ctm);
    }

    function animate(){
      if (!dragging) return;
      raf = requestAnimationFrame(animate);
      const cx = parseFloat(currentCircle.getAttribute('cx')||currentCircle.getAttribute('data-x')||0);
      const cy = parseFloat(currentCircle.getAttribute('cy')||currentCircle.getAttribute('data-y')||0);
      const nx = lerp(cx, lastPos.x, 0.22);
      const ny = lerp(cy, lastPos.y, 0.22);
      currentCircle.setAttribute('cx', nx);
      currentCircle.setAttribute('cy', ny);
      currentCircle.setAttribute('data-x', nx);
      currentCircle.setAttribute('data-y', ny);
      // update label if exists
      const g = currentCircle.parentNode;
      const label = g.querySelector('text.state-label, text');
      if (label) { label.setAttribute('x', nx); label.setAttribute('y', ny); }
      // update MACHINE state coords
      const sid = currentCircle.getAttribute('data-id') || g.getAttribute('data-id');
      const sObj = (window.MACHINE && window.MACHINE.states)? window.MACHINE.states.find(x=>x.id===sid):null;
      if (sObj) { sObj.x = nx; sObj.y = ny; }
      // refresh edges
      if (typeof updateEdgesForState === 'function') updateEdgesForState(sid);
      else doRender();
    }

    function startDrag(circle, evt){
      // only when move tool active
      const moveActive = document.getElementById('tool-move') && document.getElementById('tool-move').classList.contains('active');
      if (!moveActive) return;
      pushUndo();
      dragging = true;
      currentCircle = circle;
      circle.classList.add('state-selected');
      const p = getPoint(evt);
      lastPos.x = p.x; lastPos.y = p.y;
      animate();
      evt.preventDefault();
    }
    function moveDrag(evt){
      if (!dragging) return;
      const p = getPoint(evt);
      lastPos.x = p.x; lastPos.y = p.y;
      // clamp to viewBox
      const vb = svg.viewBox.baseVal || {x:0,y:0,width:1400,height:900};
      lastPos.x = Math.min(Math.max(lastPos.x, vb.x+30), vb.x+vb.width-30);
      lastPos.y = Math.min(Math.max(lastPos.y, vb.y+30), vb.y+vb.height-30);
    }
    function endDrag(){
      if (!dragging) return;
      dragging = false;
      if (currentCircle) currentCircle.classList.remove('state-selected');
      if (raf) { cancelAnimationFrame(raf); raf = null; }
      currentCircle = null;
      doRender();
    }

    // attach listeners on circles (use event delegation)
    statesGroup.addEventListener('pointerdown', function(e){
      const tgt = e.target.closest('circle[data-id], g[data-id]');
      if (!tgt) return;
      // find circle element
      let circleEl = tgt.tagName.toLowerCase()==='circle' ? tgt : tgt.querySelector('circle[data-id]');
      if (!circleEl && tgt.tagName.toLowerCase()==='g') circleEl = tgt.querySelector('circle');
      if (!circleEl) return;
      startDrag(circleEl, e);
      if (tgt.setPointerCapture) try{ tgt.setPointerCapture(e.pointerId); }catch(e){}
    });
    svg.addEventListener('pointermove', moveDrag);
    svg.addEventListener('pointerup', endDrag);
    svg.addEventListener('pointercancel', endDrag);
    svg.addEventListener('touchmove', function(e){ if (dragging) { moveDrag(e); e.preventDefault(); } }, {passive:false});
    svg.addEventListener('touchend', endDrag, {passive:false});
  }

  // --- Export to PNG (1:1 replica) ---
  function exportSvgToPng(svgEl, callback){
    try {
      const serializer = new XMLSerializer();
      const clone = svgEl.cloneNode(true);
      // inline computed styles for all elements
      function inline(el){
        const cs = window.getComputedStyle(el);
        let s = '';
        for (let i=0;i<cs.length;i++){
          const prop = cs[i];
          try{
            const val = cs.getPropertyValue(prop);
            if (val) s += prop+':'+val+';';
          }catch(e){}
        }
        el.setAttribute('style', s);
        for (let ch of Array.from(el.children)) inline(ch);
      }
      inline(clone);
      // ensure width/height attributes on clone
      const vb = svgEl.viewBox.baseVal;
      clone.setAttribute('width', vb.width);
      clone.setAttribute('height', vb.height);
      const xml = serializer.serializeToString(clone);
      const svg64 = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(xml)));
      const img = new Image();
      img.onload = function(){
        const canvas = document.createElement('canvas');
        canvas.width = img.width; canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img,0,0);
        callback(canvas.toDataURL('image/png'));
      };
      img.onerror = function(e){ console.error('export err', e); callback(null); };
      img.src = svg64;
    } catch(e){ console.error(e); callback(null); }
  }

  function patchExportButton(){
    if (!exportBtn || !svg) return;
    exportBtn.addEventListener('click', function(){
      exportSvgToPng(svg, function(data){
        if (!data){ alert('Export failed'); return; }
        const a = document.createElement('a');
        a.href = data; a.download = 'automaton-canvas.png';
        document.body.appendChild(a); a.click(); a.remove();
      });
    });
  }

  // --- Self-loop strong curvature ---
  function getLoopPathAndLabel(cx, cy, r, states, id, symbol) {
    const loopRadius = 48;
    const dirs = [{dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}];
    for (let d of dirs){
      const checkX = cx + d.dx*(r+loopRadius);
      const checkY = cy + d.dy*(r+loopRadius);
      let safe = true;
      for (const s of (states||[])){
        if (s.id===id) continue;
        if (Math.hypot((s.x||0)-checkX, (s.y||0)-checkY) < r*2) { safe=false; break; }
      }
      if (safe){
        const offX = d.dx * loopRadius * 2.2;
        const offY = d.dy * loopRadius * 2.2;
        const pathData = `M ${cx} ${cy - r} C ${cx - offX} ${cy + offY}, ${cx + offX} ${cy + offY}, ${cx} ${cy - r}`;
        const labelX = cx + d.dx*(r+loopRadius+28);
        const labelY = cy + d.dy*(r+loopRadius+28);
        return {pathData, labelX, labelY};
      }
    }
    return {pathData:`M ${cx} ${cy - r} C ${cx - 40} ${cy - r - 40}, ${cx + 40} ${cy - r - 40}, ${cx} ${cy - r}`, labelX:cx, labelY:cy - r - 40};
  }

  // --- Conversion algorithms (epsilon->nfa, nfa->dfa, minimize) ---
  function epsilonClosure(stateId, transitions){
    const stack=[stateId]; const closure=new Set([stateId]);
    while(stack.length){
      const s = stack.pop();
      for (const t of transitions){
        if (t.from===s && (t.symbol==='' || t.symbol==='ε')) {
          if (!closure.has(t.to)){ closure.add(t.to); stack.push(t.to); }
        }
      }
    }
    return Array.from(closure);
  }
  function epsilonToNfa(machine){
    const m = JSON.parse(JSON.stringify(machine));
    const newTrans = [];
    for (const st of m.states){
      const clos = epsilonClosure(st.id, m.transitions);
      for (const s of clos){
        for (const t of m.transitions){
          if ((t.symbol!=='' && t.symbol!=='ε') && t.from===s){
            newTrans.push({from: st.id, to: t.to, symbol: t.symbol});
          }
        }
      }
      for (const s of clos){
        const sf = m.states.find(x=>x.id===s);
        if (sf && sf.accepting){
          const orig = m.states.find(x=>x.id===st.id);
          if (orig) orig.accepting = true;
        }
      }
    }
    m.transitions = newTrans;
    m.type = 'NFA';
    return m;
  }
  function nfaToDfa(nfa){
    const alphabet = Array.from(new Set((nfa.alphabet||[]).filter(s=>s!=='' && s!=='ε')));
    function fullClosure(setArr){
      const s = new Set(setArr);
      const stack = [...setArr];
      while(stack.length){
        const cur = stack.pop();
        for (const t of nfa.transitions){
          if (t.from===cur && (t.symbol===''||t.symbol==='ε')){
            if (!s.has(t.to)){ s.add(t.to); stack.push(t.to); }
          }
        }
      }
      return Array.from(s);
    }
    const startSet = fullClosure([nfa.states[0].id]);
    const dstates = [startSet];
    const dtrans = [];
    const mapId = arr=>arr.sort().join(',');
    const queue=[startSet];
    while(queue.length){
      const S = queue.shift();
      const sid = mapId(S);
      for (const a of alphabet){
        const dest = new Set();
        for (const s of S){
          for (const t of nfa.transitions){
            if (t.from===s && t.symbol===a) dest.add(t.to);
          }
        }
        if (!dest.size) continue;
        const destFull = fullClosure(Array.from(dest));
        const did = mapId(destFull);
        if (!dstates.find(x=>mapId(x)===did)){ dstates.push(destFull); queue.push(destFull); }
        dtrans.push({from: sid, to: did, symbol: a});
      }
    }
    const dstateObjs = dstates.map((s,i)=>({id: mapId(s) || ('q'+i), x:200 + i*80, y:200 + (i%5)*80, accepting: s.some(id=> (nfa.states.find(x=>x.id===id)||{}).accepting), initial: i===0}));
    return {type:'DFA', states: dstateObjs, transitions: dtrans, alphabet: alphabet};
  }
  function minimizeDfa(dfa){
    const states = dfa.states.map(s=>s.id);
    const alph = dfa.alphabet || Array.from(new Set(dfa.transitions.map(t=>t.symbol)));
    const isAcc = id => !!(dfa.states.find(s=>s.id===id && s.accepting));
    let P = [states.filter(isAcc), states.filter(s=>!isAcc(s))].filter(x=>x.length);
    let changed = true;
    while(changed){
      changed = false;
      const newP = [];
      for (const block of P){
        const groups = {};
        for (const s of block){
          const sig = alph.map(a=>{
            const t = dfa.transitions.find(tr=>tr.from===s && tr.symbol===a);
            const to = t ? t.to : '__';
            const idx = P.findIndex(b=>b.includes(to));
            return idx;
          }).join('|');
          groups[sig] = groups[sig] || [];
          groups[sig].push(s);
        }
        const vals = Object.values(groups);
        if (vals.length>1) changed = true;
        newP.push(...vals);
      }
      P = newP;
    }
    const rep = {};
    P.forEach((block,i)=>{ const id='S'+i; block.forEach(s=>rep[s]=id); });
    const newStates = P.map((block,i)=>({id:'S'+i, initial: block.some(b=>dfa.states.find(s=>s.id===b && s.initial)), accepting: block.some(b=>dfa.states.find(s=>s.id===b && s.accepting)), x:200+i*80, y:200}));
    const newTrans = [];
    for (const block of P){
      const src = rep[block[0]];
      for (const a of alph){
        const t = dfa.transitions.find(tr=>tr.from===block[0] && tr.symbol===a);
        if (t){ const to = rep[t.to]; if (to) newTrans.push({from: src, to: to, symbol: a}); }
      }
    }
    return {type:'DFA', states:newStates, transitions:newTrans, alphabet:alph};
  }

  // Hook mode change: apply conversions automatically
  let lastMode = (modeSelect && modeSelect.value) ? modeSelect.value : 'DFA';
  if (modeSelect){
    modeSelect.addEventListener('change', function(e){
      const newMode = modeSelect.value;
      try {
        // snapshot before conversion
        pushUndo();
        if (lastMode === 'ENFA' && newMode === 'NFA') {
          // eps -> nfa
          window.MACHINE = epsilonToNfa(window.MACHINE || window.MACHINE);
        } else if ((lastMode === 'ENFA' || lastMode === 'NFA') && newMode === 'DFA') {
          // nfa -> dfa (ensure eps removed first)
          if (lastMode === 'ENFA') window.MACHINE = epsilonToNfa(window.MACHINE || window.MACHINE);
          window.MACHINE = nfaToDfa(window.MACHINE || window.MACHINE);
        } else if (lastMode === 'DFA' && newMode === 'DFA') {
          // minimize
          window.MACHINE = minimizeDfa(window.MACHINE || window.MACHINE);
        }
        clampStatesToView();
        doRender();
      } catch(err){ console.error('conversion failed', err); }
      lastMode = newMode;
    });
  }

  // --- clamp states into view ---
  function clampStatesToView(){
    try {
      if (!svg || !window.MACHINE) return;
      const vb = svg.viewBox.baseVal || {x:0,y:0,width:1400,height:900};
      for (const s of (window.MACHINE.states||[])){
        if (!isFinite(s.x) || !isFinite(s.y)){ s.x = vb.x + vb.width/2; s.y = vb.y + vb.height/2; }
        s.x = Math.min(Math.max(s.x, vb.x+36), vb.x+vb.width-36);
        s.y = Math.min(Math.max(s.y, vb.y+36), vb.x+vb.height-36);
      }
    } catch(e){ console.error(e); }
  }

  // --- temporary diversion for transitions during animation ---
  function divertTransitionDuringAnimation(pathEl){
    if (!pathEl) return;
    const d = pathEl.getAttribute('d')||'';
    if (d.indexOf('C')>=0){
      const modified = d.replace(/(-?\d+(\.\d+)?)/g, function(m){
        return (parseFloat(m)*1.08).toFixed(2);
      });
      pathEl.setAttribute('d', modified);
      setTimeout(()=>{ try{ pathEl.setAttribute('d', d); }catch(e){} }, 700);
    }
  }

  // --- Expand practice bank if present ---
  function expandPracticeBank(){
    try {
      if (!window.PRACTICE_BANK) return;
      ['DFA','NFA','ENFA'].forEach(mode=>{
        const bank = window.PRACTICE_BANK[mode] || {};
        ['basic','medium','easy'].forEach(level=>{
          const arr = bank[level] || [];
          let idx = 0;
          while (arr.length < 10) {
            const template = arr[idx % (arr.length||1)] || {q:'Auto-generated', machine:{states:[],transitions:[]}};
            const copy = JSON.parse(JSON.stringify(template));
            copy.q = (copy.q||'Practice') + ' (extra '+(arr.length+1)+')';
            arr.push(copy);
            idx++; if (idx>100) break;
          }
          bank[level] = arr;
        });
        window.PRACTICE_BANK[mode] = bank;
      });
    } catch(e){ console.error('expand bank', e); }
  }

  // --- Initialize integrations after DOM ready ---
  function init(){
    injectUndoRedoButtons();
    setupSmoothMoveTool();
    patchExportButton();
    expandPracticeBank();
    clampStatesToView();
    // ensure our stronger self-loop function available globally
    window.getLoopPathAndLabel = getLoopPathAndLabel;
    window.epsilonToNfa = epsilonToNfa;
    window.nfaToDfa = nfaToDfa;
    window.minimizeDfa = minimizeDfa;
    window.divertTransitionDuringAnimation = divertTransitionDuringAnimation;
    // try to hook into existing drawTransitionLine if present
    if (typeof window.drawTransitionLine === 'function'){
      const orig = window.drawTransitionLine;
      window.drawTransitionLine = function(from,to,symbol,edgeEl,labelEl){
        try {
          if (from && to && ((from.id && to.id && from.id===to.id) || (from===to))) {
            const pos = (from.x!==undefined) ? {x:from.x,y:from.y} : {x: parseFloat(from.getAttribute('cx')||0), y: parseFloat(from.getAttribute('cy')||0)};
            const out = getLoopPathAndLabel(pos.x,pos.y, from.r||30, window.MACHINE.states||[], from.id||from.getAttribute('data-id'), symbol);
            if (edgeEl) edgeEl.setAttribute('d', out.pathData || out);
            if (labelEl){ labelEl.setAttribute('x', out.labelX); labelEl.setAttribute('y', out.labelY); }
            return;
          }
        } catch(e){}
        return orig(from,to,symbol,edgeEl,labelEl);
      };
    }
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();

})();
</script>
<!-- END INTEGRATED PATCH -->


<script>
// Alias so older init calls to setupSmoothMove() still work
if(typeof setupSmoothMove === 'undefined' && typeof setupSmoothMoveTool === 'function'){
  function setupSmoothMove(){ return setupSmoothMoveTool(); }
}
</script>

<script>
function addToolbarButtons(){ try{ if(typeof injectUndoRedoButtons==='function') injectUndoRedoButtons(); }catch(e){} }
</script>

<!-- MOVE TOOL PATCH -->
<script>
(function(){
  const svg = document.getElementById('dfaSVG');
  const statesGroup = document.getElementById('states');
  const edgesGroup = document.getElementById('edges');

  if(!svg || !statesGroup || !edgesGroup) return;

  let draggingState = null;
  let draggingTransition = null;
  let lastPoint = null;
  let raf = null;

  function getPoint(evt){
    const pt = svg.createSVGPoint();
    if (evt.touches && evt.touches[0]){
      pt.x = evt.touches[0].clientX; pt.y = evt.touches[0].clientY;
    } else {
      pt.x = evt.clientX; pt.y = evt.clientY;
    }
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  // State dragging
  function startStateDrag(circle, evt){
    draggingState = circle;
    circle.setAttribute('stroke','red');
    lastPoint = getPoint(evt);
    raf = requestAnimationFrame(animateState);
    evt.preventDefault();
  }

  function animateState(){
    if (!draggingState) return;
    raf = requestAnimationFrame(animateState);
    const cx = parseFloat(draggingState.getAttribute('cx'));
    const cy = parseFloat(draggingState.getAttribute('cy'));
    const nx = cx + (lastPoint.x - cx) * 0.3;
    const ny = cy + (lastPoint.y - cy) * 0.3;
    draggingState.setAttribute('cx',nx);
    draggingState.setAttribute('cy',ny);
    // move label
    const g = draggingState.parentNode;
    const label = g.querySelector('text');
    if (label){ label.setAttribute('x',nx); label.setAttribute('y',ny); }
    // update MACHINE model
    const id = g.getAttribute('data-id') || draggingState.getAttribute('data-id');
    if (window.MACHINE){
      const st = window.MACHINE.states.find(s=>s.id===id);
      if (st){ st.x=nx; st.y=ny; }
    }
    // update transitions
    updateConnectedTransitions(id,nx,ny);
  }

  function endStateDrag(){
    if (!draggingState) return;
    draggingState.removeAttribute('stroke');
    cancelAnimationFrame(raf);
    draggingState = null;
  }

  // Transition dragging
  function startTransitionDrag(path, evt){
    draggingTransition = path;
    path.setAttribute('stroke','red');
    lastPoint = getPoint(evt);
    evt.preventDefault();
  }

  function dragTransition(evt){
    if (!draggingTransition) return;
    const p = getPoint(evt);
    const dx = p.x - lastPoint.x;
    const dy = p.y - lastPoint.y;
    lastPoint = p;

    // Adjust curvature: apply offset as quadratic bezier control
    let d = draggingTransition.getAttribute('d');
    if (!d.includes('Q')){
      // convert straight line M x y L x y to quadratic M x y Q cx cy x y
      const pts = d.match(/-?\d+(\.\d+)?/g).map(Number);
      if (pts.length>=4){
        const mx=pts[0], my=pts[1], lx=pts[2], ly=pts[3];
        const cx = (mx+lx)/2 + dx;
        const cy = (my+ly)/2 + dy;
        d = `M ${mx} ${my} Q ${cx} ${cy} ${lx} ${ly}`;
      }
    } else {
      // adjust existing control point
      d = d.replace(/Q\s+(-?\d+(\.\d+)?)\s+(-?\d+(\.\d+)?)/,
        function(_,x1,__,y1){
          return `Q ${parseFloat(x1)+dx} ${parseFloat(y1)+dy}`;
        });
    }
    draggingTransition.setAttribute('d',d);
  }

  function endTransitionDrag(){
    if (!draggingTransition) return;
    draggingTransition.removeAttribute('stroke');
    draggingTransition = null;
  }

  // Reset curve on double click
  edgesGroup.addEventListener('dblclick', function(e){
    const path = e.target.closest('path');
    if (!path) return;
    const d = path.getAttribute('d');
    const pts = d.match(/-?\d+(\.\d+)?/g);
    if (pts && pts.length>=4){
      path.setAttribute('d',`M ${pts[0]} ${pts[1]} L ${pts[2]} ${pts[3]}`);
    }
  });

  // Update connected transitions when a state moves
  function updateConnectedTransitions(stateId, nx, ny){
    if (!window.MACHINE) return;
    for (const t of window.MACHINE.transitions){
      if (t.from===stateId || t.to===stateId){
        const from = window.MACHINE.states.find(s=>s.id===t.from);
        const to = window.MACHINE.states.find(s=>s.id===t.to);
        const path = edgesGroup.querySelector(`path[data-from='${t.from}'][data-to='${t.to}']`);
        if (path && from && to){
          path.setAttribute('d',`M ${from.x} ${from.y} L ${to.x} ${to.y}`);
        }
      }
    }
  }

  // Attach listeners
  statesGroup.addEventListener('mousedown', function(e){
    if (!document.getElementById('tool-move')?.classList.contains('active')) return;
    const circle = e.target.closest('circle[data-id]');
    if (circle) startStateDrag(circle,e);
  });
  svg.addEventListener('mousemove', function(e){
    if (draggingState) lastPoint = getPoint(e);
    if (draggingTransition) dragTransition(e);
  });
  svg.addEventListener('mouseup', function(){
    endStateDrag();
    endTransitionDrag();
  });

  edgesGroup.addEventListener('mousedown', function(e){
    if (!document.getElementById('tool-move')?.classList.contains('active')) return;
    const path = e.target.closest('path');
    if (path) startTransitionDrag(path,e);
  });
})();
</script>

</body>
</html>
